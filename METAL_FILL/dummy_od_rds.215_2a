//******************************************************************************************
// CALIBRE DUMMY OD POLY INSERTION UTILITY - Dummy_OD_PO_Calibre_0.18um.215_2a (04/16/2021)
// FOR ALL TSMC 0.18UM 1P6M PROCESS 
// DESIGN RULE DOCUMENT: T-018-LO-DR-001 VER 2.15_2
// UTILITY DOCUMENT: T-018-LO-DR-001-C2 VER 2.15_2a
// Tech File Ver: 2.15_2a
//******************************************************************************************

///***********************************************************************************
/// TSMC developed this deck using Mentor Graphics proprietary SVRF and TVF formats.
/// The deck is to be used only in Calibre tools.
///***********************************************************************************
///
///  DISCLAIMER
///
///  The information contained herein is provided by TSMC on an "AS IS" basis
///  without any warranty, and TSMC has no obligation to support or otherwise
///  maintain the information.  TSMC disclaims any representation that the
///  information does not infringe any intellectual property rights or proprietary
///  rights of any third parties.  There are no other warranties given by TSMC,
///  whether express, implied or statutory, including, without limitation, implied
///  warranties of merchantability and fitness for a particular purpose.
///
///  STATEMENT OF USE
///
///  This information contains confidential and proprietary information of TSMC.
///  No part of this information may be reproduced, transmitted, transcribed,
///  stored in a retrieval system, or translated into any human or computer
///  language, in any form or by any means, electronic, mechanical, magnetic,
///  optical, chemical, manual, or otherwise, without the prior written permission
///  of TSMC.  This information was prepared for informational purpose and is for
///  use by TSMC's customers only.  TSMC reserves the right to make changes in the
///  information at any time and without notice.
///
///-------------------------------------------------------------------------------------------
///
///  NOTICE: (Read Me First!)
///
///  1. If the input GDS file does not include all the layers in the
///     INPUT LAYER BLOCK, for example, they are generated by logic
///     operations, please make sure the consistence with original
///     layer definition.
///
//*  2. The runset is tested and developed on Calibre v2018.4_25.17, please use 
///     this or newer TSMC qualified version of Calibre to execute this runset.
///
///*******************************************************************************
///      CORRECT USAGE: 								 
///*******************************************************************************
/// The following options are very important, user needs to turn on or turn off	 
/// the options according to their application.					 
///										 
///  (1) #DEFINE UseprBoundary :
///      #DEFINE ChipWindowUsed :
///	The utility will use the boundary generated by defined (tape-out) layers
///	for the insertion by default.
///	If user wants to specify the window of chip by prBoundary(62) layer,
/// please un-comment the line as below:
///
///      #DEFINE UseprBoundary
///
///	If customers want to specified the window of chip exactly, please un-comment
///	the line as below:
///
///		#DEFINE ChipWindowUsed 
///
///	Then modifiy the Variables ( xLB, yLB) for the coordinate of left-bottom corner
///	and ( xRT, yRT) for the coordinate of right-top corner of the user-defined chip window
///	Moreover, the line below is an un-used layer number for constructing the chip window
///
///		LAYER ChipWindow 500
///
///	If layer number 500 is used, please assign another layer number without conflict.
///
///  (2) #DEFINE dmOnCorner : 
///	The utility will not insert dummy layers in the chip corners and reserve the
///	space for sealring by default.
///	If customers want to add dummy inside whole layout extent like sub-cell or macro 
///	level applications. Please un-comment the line as below:
///
///		#DEFINE dmOnCorner
///
///	For cell and macro level layout, please turn on "dmOnCorner" to insert dummy on corner.
///										 
///  (3) #DEFINE BigDieCorner : 
///	This option only effective when "dmOnCorner" is disabled. By default, the shape
///	of the chip corner is big-die style. 
///	If the chip size is small and customers need the small-die shape of chip corner.
///	Please comment the line as below:
///
///		//#DEFINE BigDieCorner
///
///  (4) #DEFINE WithSealring : 
///	By default, this option is disabled for layout without sealring structure. 
///	If the target layout for dummy pattern insertion already has the sealring, 
///	users need to enable this option. The dummy patterns would be only inserted 
///	inside the region that was shrinked "20um" inward. This could solve the overlap 
///	between dummy patterns and CDU regions.
///	Please un-comment the line as below to enable this option:
///
///		#DEFINE WithSealring
///
///  (5) #DEFINE dmOnCBM : 
///	The utility will not insert dummy patterns in the CBM region of mimcap by default.
///	If customers want to add dummy patterns inside CBM region. Please un-comment the line as below:
///
///		//#DEFINE dmOnCBM
///
///  (6) #DEFINE REVISE_DOD : 
///	Generate DOD according to existed DPO layers inserted by this utility last time,
///	(exact same dimensions) and only DOD will be output. This is for DOD mask revision
///	only, please un-comment this opion if you need.
///
///		#DEFINE REVISE_DOD
///
///  (7) #DEFINE REVISE_DPO : 
///	Generate DPO according to existed DOD layers inserted by this utility last time,
///	(exact same dimensions) and only DPO will be output. This is for DPO mask revision
///	only, please un-comment this option if you need. 
///
///		#DEFINE REVISE_DPO
///							
///  (8) #DEFINE ADD_DPO_ALSO : 
///	By default, this utility will not generate dummy poly patterns.
///	It is strongly recommended that dummy poly should be inserted into the layout
///	to increase the process quality. Please un-comment the line as below to generate
///	both dummy OD and dummy poly at the same time: 
///
///		#DEFINE ADD_DPO_ALSO
///

///  (9) #DEFINE MIXED_SCHEME : 
///	If the option is turned off, the output datatype of generated dummy OD and PO patterns are set to 
///	"0" (drawing) and then the inserted dummy patterns will be taken as drawing layer in
///	design rule checking (DRC). If the option is turned on, the output datatye of generated
///	patterns will be set to "1" (dummy) and DRC will not check the inserted dummmy patterns.
///
///		#DEFINE MIXED_SCHEME
///
///  (10) #DEFINE RFSWITCH : 
///	Customers could enable this option for RFSWITCH process
///	To enable this function, please un-comment the line as below:
///
///              //#DEFINE RFSWITCH	

///*******************************************************************************
// NOTE:
//*******************************************************************************
// If this utility was used for cell level design, below options or variable need to take care.
//
// 1. Cell boundary: turn on option "ChipWindowUsed" to define cell boundary or use whole layout extent.
// 2. Dummy on cell corner: turn on option "dmOnCorner" to insert dummy on cell corner.
// 3. Dummy to cell boundary: variable "dm2Chip" defines min. space between dummy and boundary,
//    user can revise this variable to change the space between dummy and cell boundary.
//    Please note that dummy OD or POLY must be enclosed by chip edge >= 5.0um.     
//
//*******************************************************************************
//
// REVISION:
//
// 2.6a 01/02/2006 Allen Tsai
//	1) Newly created.
//	2) Add LOGO layers.
// 2.6b_pre 01/15/2007 Y.J. Chuang
//	1) Add a switch to control output data type of dummy OD&PO.
//	   The default output data type is "0".
//	2) Add TSV to Exclude Layer for dummy OD&PO insertion.
// 2.8a 07/15/2010 R.H. Zhang
//      1) Added layer HVDMY, HV60DMY, NLVT, HVNW to exclude HV region for dummy OD&PO insertion.
//      2) Added layer FLASH to exclude FLASH region for dummy OD&PO insertion. 
//      3) Added layer DT to exclude DT region for dummy OD&PO insertion. 
//      4) Added layer BJTDUMMY to exclude BJTDUMMY region for dummy OD&PO insertion. 
//      5) Added dmOnCBM switch for dummy pattern in the CBM region.
// 2.8b_eval 01/16/2012 Franky Chen
//      1) Offer non-encrypt version
// 2.10a 05/10/2013 Franky Chen
//  1) Add C018 RFSWITCH process
// 2.15_2a 04/16/2021 P.Cao
//  1) Add layer BIAS25VNDMY, SH_N to exclude HV region for dummy OD/PO insertion
//  2) Add UseprBoundary switch
//  3) Change MIXED_SCHEME switch's default state to ON

/* SWITCH DEFINITION START */
//OPTION SETUP
//******* User defined chip area  **************************************

//#DEFINE UseprBoundary  // Turn on to specify chip boundary by prBoundary(62;0) layer
//#DEFINE ChipWindowUsed
VARIABLE xLB   0.0	// x-coordinate of left-bottom corner for user defined chip window 
VARIABLE yLB   0.0	// y-coordinate of left-bottom corner for user defined chip window 
VARIABLE xRT   1000.0	// x-coordinate of right-top corner for user defined chip window  
VARIABLE yRT   1000.0	// y-coordinate of right-top corner for user defined chip window 
LAYER ChipWindow 500

//******* Options for chip corner empty area definition ****************

#DEFINE dmOnCorner	// DOD inside Chip Corner ? (apply to cell or macro level design)
#DEFINE BigDieCorner	// Is chip corner the shape for big die ?
#DEFINE WithSealring	// Already with the sealring structure assembled?
#DEFINE dmOnCBM	// By default, the dummy pattern will not be inserted in the CBM region. If customer want to add dummy pattern in the CBM region, please turn it on.  
//#DEFINE RFSWITCH 		// for RFSWITCH process


//******* Options for single dummy layer revision **********************
#DEFINE ADD_DPO_ALSO	// Generate DPO also with DOD. It's strongly recommended to enable it.
//#DEFINE REVISE_DOD	// Generate only DOD according to existed DPO layers 
//#DEFINE REVISE_DPO	// Generate only DPO according to existed DOD layers 
#DEFINE MIXED_SCHEME	// Set output data type of DOD and DPO as "1". The default output data type is "0".

//********************************************************************************
//
// ENVIRONMENT SETUP
//------------------

PRECISION    1000
RESOLUTION      5    // tool resolution

LAYOUT SYSTEM GDSII
LAYOUT PATH "top_dummy.gds"
LAYOUT PRIMARY "topcell"	
//Please do not stream-in directly if the topcell name is the same as the original one.
DRC RESULTS DATABASE "od_dummy.gds" GDSII
//DRC RESULTS DATABASE "DOD.gds" GDSII _DOD
DRC SUMMARY REPORT "DOD.sum" 
DRC MAXIMUM RESULTS ALL
DRC KEEP EMPTY NO
//LAYOUT ALLOW DUPLICATE CELL YES
//LAYOUT ERROR ON INPUT NO

/* SWITCH DEFINITION END */
//******* Layer Assignment *********************************************


// DRAWN LAYER DEFINITIONS
//------------------------
LAYER NWELi	2	// Nwell technology
LAYER DIFFi	3	// Active areas


LAYER EODi	307
LAYER MAP 3   DATATYPE 7 307    //Define extend OD region on drain side
LAYER DOD	1340	// Dummy OD (DIFF)
LAYER MAP 3   DATATYPE 1 1340	// Mapping (3;1) to 1340 for dummy OD
LAYER ODBLK	1350	// DOD blocking for insertion
LAYER MAP 150 DATATYPE 20 1350
LAYER PDIFFi	11	// Active areas
LAYER NDIFFi	12	// Active areas
LAYER OD2i	4	// Define thick gate oxides
LAYER POLYi	13	// Polysilicon gates, interconnect
LAYER DPO	1342	// Dummy Poly
LAYER MAP 13  DATATYPE 1 1342	// Mapping (13;1) to 1342 for dummy PO
LAYER POBLK	1351	// DPO blocking for insertion
LAYER MAP 150 DATATYPE 21 1351
LAYER PPi	7	// P+ S/D imlant
LAYER NPi	8	// N+ S/D imlant
LAYER prBoundary 620
LAYER MAP 62 DATATYPE 0 620

LAYER FLASH	94	// FLASH IP outline
LAYER HVNWi	99	// High voltage NW
LAYER HVOXi	180	// HV region define layer
LAYER HVDMYi	401
LAYER MAP 141 DATATYPE 52 401
LAYER NLVTi	405
LAYER MAP 141 DATATYPE 63 405
LAYER HVSHNi 312
LAYER MAP 141 DATATYPE 2 312
LAYER BIAS25VNDMY 18290
LAYER MAP 182 DATATYPE 90 18290

LAYER HV60DMY	14170
LAYER MAP 141 DATATYPE 70 14170
LAYER CTMDMYUD	3150
LAYER MAP 131 DATATYPE 50 3150
LAYER RFDUMMYUD	6050
LAYER MAP 160 DATATYPE 50 6050


//SOI layers
LAYER DTi	171	// Deep trench
LAYER DTBLK  2046  // Deep trench block
LAYER MAP 171 DATATYPE 2 2046
LAYER NLD 2040 
LAYER MAP 204 DATATYPE 0 2040
LAYER SOILDi 2041 		// to recognize the Lateral Diode device for SOI process 
LAYER MAP 204 DATATYPE 1 2041
LAYER SOIBTi 2042		// to recognize the BCM(body contact MOS) device for SOI process
LAYER MAP 204 DATATYPE 2 2042
LAYER SOIDRNi 2043
LAYER MAP 204 DATATYPE 3 2043
LAYER SOILGi 2044
LAYER MAP 204 DATATYPE 4 2044
LAYER SOI1Gi 2045
LAYER MAP 204 DATATYPE 5 2045
LAYER HVD_Ni 2048
LAYER MAP 204 DATATYPE 8 2048
LAYER HVS_Ni 2049
LAYER MAP 204 DATATYPE 9 2049
LAYER HV_PBi 20430
LAYER MAP 204 DATATYPE 30 20430
LAYER HVD2_Ni 20441
LAYER MAP 204 DATATYPE 41 20441
LAYER HVD_ND6i	20442
LAYER MAP 204 DATATYPE 42 20442


LAYER CB2i	177	// For BiCMOS passivation-2 opening window
LAYER RVi	188	// Hole of SUTM4 and AP-MD interconnect
LAYER MAP 189 DATATYPE 1 1891
LAYER APi	1891	// AL pad or RDL in SiGe PA and SOI process
LAYER PM1i                 5001	    // Polymide (if drawn)
LAYER MAP 5   DATATYPE 1   5001	    
LAYER PM2i                 5002	    // Polymide (if drawn)
LAYER MAP 5   DATATYPE 2   5002
LAYER CU_PPI_10UM   429           // Cu_PPI_10um interconnection between Polymide1 and Polymide2 for WLCSP
LAYER MAP 42 DATATYPE 9 429
LAYER CU_PPI_4UM   4210           // Cu_PPI_4um interconnection between Polymide1 and Polymide2 for WLCSP
LAYER MAP 42 DATATYPE 10 4210

LAYER BJTDUMMY	49	// BJT dummy layer
LAYER DIODUMMY	56	// Diode dummy layer
LAYER RPDUMMY   54
LAYER COi	15	// Define connection from M1 to S/D and Gate
LAYER M1i	16	// First Metal layer
LAYER VIA1i	17	// Define connection from M2 to M1
LAYER M2i	18	// Second Metal layer
LAYER VIA2i	27	// Define connection from M3 to M2
LAYER M3i	28	// Third Metal layer
LAYER VIA3i	29	// Define connection from M4 to M3
LAYER M4i	31	// Fourth Metal layer
LAYER VIA4i	32	// Define connection from M5 to M4
LAYER M5i	33	// Fifth Metal layer
LAYER VIA5i	39	// Define connection from M6 to M5
LAYER M6i	38	// Sixth Metal layer  
LAYER M1_PIN_TEXT	4000
LAYER MAP 40 TEXTTYPE 0	4000
LAYER M2_PIN_TEXT	4100
LAYER MAP 41 TEXTTYPE 0	4100
LAYER M3_PIN_TEXT	4200
LAYER MAP 42 TEXTTYPE 0	4200
LAYER M4_PIN_TEXT	4300
LAYER MAP 43 TEXTTYPE 0	4300
LAYER M5_PIN_TEXT	4400
LAYER MAP 44 TEXTTYPE 0	4400
LAYER M6_PIN_TEXT	4500
LAYER MAP 45 TEXTTYPE 0	4500


LAYER VIADi	167	// Define connect from MD to Top Metal
LAYER MDi	168	// RDL Metal layer above Top Metal
LAYER CBi	19	// Passivation opening for Bond Pad
LAYER CBDi	169	// Definition of passivation window for bump
LAYER UBMi	170	// Bond Pad definition for RDL
LAYER PPIi	189	// Post Passivation RDL
LAYER RPOi	34	// Salicided Block Layer
LAYER NTNi	129	// Native NMOS blocked implantation
LAYER PLMIDEi	89	// Polymide (if drawn)
//LAYER  FUSEi	235	// Fuse window
LAYER DNWi	82	// Deep N-WELL
LAYER VTMPi	23	// Blocking region of PMOS VT implantation
LAYER VTMNi	24	// Blocking region of NMOS VT implantation
LAYER PV_P	71	// PV_P pmos varactor p+ implant layer
LAYER PV_N	72	// PV_N pmos varactor n+ blocking layer
LAYER HRIi	48	// High Resistor implant

// Dummy Metal layers
//-------------------
LAYER MAP 16  DATATYPE 1 316
LAYER M1DMY	316	// Metal1 dummy (if drawn)
LAYER MAP 18  DATATYPE 1 318
LAYER M2DMY	318	// Metal2 dummy (if drawn)
LAYER MAP 28  DATATYPE 1 329
LAYER M3DMY	329	// Metal3 dummy (if drawn)
LAYER MAP 31  DATATYPE 1 331
LAYER M4DMY	331	// Metal4 dummy (if drawn)
LAYER MAP 33  DATATYPE 1 333
LAYER M5DMY	333	// Metal5 dummy (if drawn)
LAYER MAP 38  DATATYPE 1 338
LAYER M6DMY	338	// Metal6 dummy (if drawn)
LAYER MAP 168 DATATYPE 1 340
LAYER MDDMY	340    	// MD dummy (if drawn)

// Metal Slot layers
//------------------
LAYER MAP 16  DATATYPE 2 321
LAYER M1SLOTi	321	// Metal1 slot (if drawn)
LAYER MAP 18  DATATYPE 2 322
LAYER M2SLOTi	322	// Metal2 slot (if drawn)
LAYER MAP 28  DATATYPE 2 323
LAYER M3SLOTi	323	// Metal3 slot (if drawn)
LAYER MAP 31  DATATYPE 2 324
LAYER M4SLOTi	324	// Metal4 slot (if drawn)
LAYER MAP 33  DATATYPE 2 325
LAYER M5SLOTi	325	// Metal5 slot (if drawn)
LAYER MAP 38  DATATYPE 2 326
LAYER M6SLOTi	326	// Metal6 slot (if drawn)
LAYER MAP 168 DATATYPE 2 328
LAYER MDSLOTi	328	// MD slot (if drawn)

// Capacitor Top Metal Layers
//---------------------------


LAYER MAP 67  DATATYPE 1 256
LAYER CTM1i	256	// Capacitor Top Metal-1

LAYER MAP 67  DATATYPE 2 257
LAYER CTM2i	257	// Capacitor Top Metal-2
LAYER MAP 67  DATATYPE 3 258
LAYER CTM3i	258	// Capacitor Top Metal-3
LAYER MAP 67  DATATYPE 4 259
LAYER CTM4i	259	// Capacitor Top Metal-4
LAYER MAP 67  DATATYPE 5 260
LAYER CTM5i	260	// Capacitor Top Metal-5

// Dummy Layers
//-------------
LAYER HOTWL	51	// Hot N-Well (SEE README HOT_NWEL NOTES)
LAYER EXCLi	55	// Exclude layer
LAYER DRCDMY	60	// DRC I/O waiver
LAYER RWDMY	52	// NWEL Resistor dummy layer
LAYER DPDMY	65	// Dummy Pad area dummy layer
LAYER PLDMY	66	// Power Line area dummy layer
LAYER SDI	58	// IO ESD region dummy layer
LAYER ESD1DMY	136	// IO ESD region dummy layer, RPO must enclose whole gate
LAYER ESD2DMY	137	// IO ESD region dummy layer, RPO enclose gate 0.05 for 3.3V
LAYER ESD3DMY	234
LAYER CTMDMY	131	// Cover metal as a capacitor bottom plate
LAYER RLPPDMY	134	// HRI high Poly resistor dummy layer
LAYER DMN2V	184	// Dummy layer to ensure N2V in N+ poly/OD resistor
LAYER DMP2V	149	// Dummy layer to ensure P2V in P+ poly/OD resistor
LAYER VARDMY	138	// Dummy layer to cover varactor device
LAYER PMDMY	236	// Dummy layer to cover fuse window and protection ring structur
LAYER FWi	235	// Fuse window when x, (x+1) = 3 
LAYER LMARK	263	// L target window for bump process
LAYER MAP 63  DATATYPE 1 263
LAYER LWI	363	// L target window for bump process
LAYER MAP 63  DATATYPE 2 363
LAYER WBDMY	183	// Dummy layer to cover the CUP pad
LAYER ESDi	30	// For 0.18um 1.8V/5V on i/o esd's implant only.
LAYER ESDIMPi 2504 // For 0.18um 3.3V esd NMOS only.
LAYER MAP 250 DATATYPE 4 2504
LAYER INDDMY	364	// Dummy layer to define inductor
LAYER MAP 139 DATATYPE 0 364
LAYER SEALRING	126	// SEAL-RING Layer used for SR.S.1 check
LAYER LOGO	178	// Dummy layer for product labels and LOGO
LAYER LUPWDMY     2551     // DRC dummy layer to waive Latch-Up rules for verified IP.
LAYER MAP 255 DATATYPE 1 2551

LAYER MAP 255 DATATYPE 4   2554
LAYER	VDDDMY 2554
LAYER MAP 255 DATATYPE 5   2555
LAYER	VSSDMY 2555
LAYER TSVi    251      // TSV region define layer.




LAYOUT TOP LAYER M1i VIA1i M1SLOTi M1DMY
LAYOUT TOP LAYER M2i VIA2i M2SLOTi M2DMY
LAYOUT TOP LAYER M3i VIA3i M3SLOTi M3DMY
LAYOUT TOP LAYER M4i VIA4i M4SLOTi M4DMY
LAYOUT TOP LAYER M5i VIA5i M5SLOTi M5DMY

LAYOUT TOP LAYER MDi VIADi MDSLOTi MDDMY M6i M6SLOTi M6DMY CBi 


M1xd = (M1i OR M1DMY) NOT M1SLOTi
M1x  = M1i NOT M1SLOTi

LAYER DM1EXCL	371
LAYER MAP 150 DATATYPE 1 371
M2xd = (M2i OR M2DMY) NOT M2SLOTi
M2x  = M2i NOT M2SLOTi

LAYER DM2EXCL	372
LAYER MAP 150 DATATYPE 2 372
M3xd = (M3i OR M3DMY) NOT M3SLOTi
M3x  = M3i NOT M3SLOTi

LAYER DM3EXCL	373
LAYER MAP 150 DATATYPE 3 373
M4xd = (M4i OR M4DMY) NOT M4SLOTi
M4x  = M4i NOT M4SLOTi

LAYER DM4EXCL	374
LAYER MAP 150 DATATYPE 4 374
M5xd = (M5i OR M5DMY) NOT M5SLOTi
M5x  = M5i NOT M5SLOTi

LAYER DM5EXCL	375
LAYER MAP 150 DATATYPE 5 375
M6xd = (M6i OR M6DMY) NOT M6SLOTi
M6x  = M6i NOT M6SLOTi

LAYER DM6EXCL	376
LAYER MAP 150 DATATYPE 6 376
MDxd = (MDi OR MDDMY) NOT MDSLOTi
MDx  = MDi NOT MDSLOTi
LAYER DMDEXCL	380
LAYER MAP 150 DATATYPE 15 380

ODi  = (DIFFi OR NDIFFi) OR PDIFFi











//******* Variables do not be modified *********************************

VARIABLE grid		0.005
VARIABLE SRwidth	20.0	// width of sealring including CDU regions

//******* Fill region and spacing definitions **************************
// 1st (big) DOD/DPO Size Space 
VARIABLE DodW1 		5.0	// 1st DOD width
VARIABLE DpoL1 		5.0	// 1st DPO length
VARIABLE DpoW1 		1.4	// 1st DPO width
VARIABLE dm2dm1		0.8	// DOD & DPO space in 1st cell
VARIABLE DodS1 		DpoW1+2*dm2dm1	// 1st DOD space (0.8+1.4+0.8)
VARIABLE DpoSX1 	DpoW1+2*dm2dm1	// 3.0, DpoSX1 == DodS1 by default
VARIABLE DpoSY1 	DodW1+2*dm2dm1	// 6.6 by default

// 2nd DOD/DPO Size Space 
VARIABLE DodW2 		2.0	// 2nd DOD width
VARIABLE DpoL2 		2.0	// 2nd DPO length
VARIABLE DpoW2 		0.6	// 2nd DPO width
VARIABLE dm2dm2		0.3	// DOD & DPO space in 2nd cell
VARIABLE DodS2 		DpoW2+2*dm2dm2	// 2nd DOD space (0.3+0.6+0.3)
VARIABLE DpoSX2 	DpoW2+2*dm2dm2	// 1.2, DpoSX2 == DodS2 by default
VARIABLE DpoSY2 	DodW2+2*dm2dm2	// 2.6 by default

// Cell size
VARIABLE cell1 		DodW1+2*dm2dm1+DpoW1	// 1st cell size: 5.0+0.8+1.4+0.8
VARIABLE cell2		DodW2+2*dm2dm2+DpoW2	// 2nd cell size: 2+0.3+0.6+0.3

// Rule values
VARIABLE dm2OD		1.2	// cell to OD: DOD.S.2, DPO.S.2
VARIABLE dm2PO		1.2	// cell to PO: DOD.S.3, DPO.S.3
VARIABLE dm2ODBLK	4.0	// DOD to ODBLK: DOD.S.4
VARIABLE dm2POBLK	4.0	// DPO to POBLK: DPO.S.4
VARIABLE dm2NW		0.6	// DOD to NW edge: DOD.S.5, DOD.EN.1
VARIABLE dm2Chip	5.0	// cell to chipedge: DOD.EN.2, DPO.EN.1
VARIABLE dm2FW		1.2	// cell to FW: DOD.S.6, DPO.S.5
VARIABLE dm2LMARK	1.2	// cell to LMARK: DOD.S.7, DPO.S.6
VARIABLE dm2NWDMY	1.2	// DOD to NW resistor DOD.S.8
#IFDEF RFSWITCH
VARIABLE dm2LOGO	0.0	// cell can not inside LOGO
#ELSE
VARIABLE dm2LOGO	3.0	// cell can not inside LOGO
#ENDIF
VARIABLE dm2INDDMY	1.2	// cell to INDDMY: DOD.S.10, DPO.S.9	 
VARIABLE dm2HV		10.0	// dummy to HV area
VARIABLE dm2BJTDUMMY	10.0	// dummy to BJTDUMMY area
VARIABLE dm2FLASH	10.0	// dummy to em-flash area
VARIABLE dm2CBM	        1.2	// dummy to CBM region of MIMCAP area
VARIABLE dm2TSV		70.0	// dummy to TSV area
VARIABLE dm2DT		1.2	// dummy to DT area
VARIABLE Dod2DOD	1.2	// DOD to DOD space: DOD.S.1
VARIABLE Dpo2DOD	0.3	// DPO to DOD space: DPO.S.9
VARIABLE Dpo2DPO	0.3	// DPO to DPO space: DPO.S.1

//******* Chip boundary pre-definition *********************************

#IFNDEF ChipWindowUsed
DummyRule.ChipWindow { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  ChipWindow NOT bulk
}
DummyRule.NWELi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  NWELi NOT bulk
}
DummyRule.DIFFi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  DIFFi NOT bulk
}
DummyRule.EODi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  EODi NOT bulk
}
DummyRule.DOD { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  DOD NOT bulk
}
DummyRule.ODBLK { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  ODBLK NOT bulk
}
DummyRule.PDIFFi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  PDIFFi NOT bulk
}
DummyRule.NDIFFi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  NDIFFi NOT bulk
}
DummyRule.OD2i { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  OD2i NOT bulk
}
DummyRule.POLYi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  POLYi NOT bulk
}
DummyRule.DPO { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  DPO NOT bulk
}
DummyRule.POBLK { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  POBLK NOT bulk
}
DummyRule.PPi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  PPi NOT bulk
}
DummyRule.NPi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  NPi NOT bulk
}
DummyRule.prBoundary { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  prBoundary NOT bulk
}
DummyRule.FLASH { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  FLASH NOT bulk
}
DummyRule.HVNWi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  HVNWi NOT bulk
}
DummyRule.HVOXi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  HVOXi NOT bulk
}
DummyRule.HVDMYi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  HVDMYi NOT bulk
}
DummyRule.NLVTi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  NLVTi NOT bulk
}
DummyRule.HVSHNi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  HVSHNi NOT bulk
}
DummyRule.BIAS25VNDMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  BIAS25VNDMY NOT bulk
}
DummyRule.HV60DMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  HV60DMY NOT bulk
}
DummyRule.CTMDMYUD { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  CTMDMYUD NOT bulk
}
DummyRule.RFDUMMYUD { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  RFDUMMYUD NOT bulk
}
DummyRule.DTi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  DTi NOT bulk
}
DummyRule.DTBLK { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  DTBLK NOT bulk
}
DummyRule.NLD { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  NLD NOT bulk
}
DummyRule.SOILDi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  SOILDi NOT bulk
}
DummyRule.SOIBTi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  SOIBTi NOT bulk
}
DummyRule.SOIDRNi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  SOIDRNi NOT bulk
}
DummyRule.SOILGi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  SOILGi NOT bulk
}
DummyRule.SOI1Gi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  SOI1Gi NOT bulk
}
DummyRule.HVD_Ni { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  HVD_Ni NOT bulk
}
DummyRule.HVS_Ni { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  HVS_Ni NOT bulk
}
DummyRule.HV_PBi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  HV_PBi NOT bulk
}
DummyRule.HVD2_Ni { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  HVD2_Ni NOT bulk
}
DummyRule.HVD_ND6i { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  HVD_ND6i NOT bulk
}
DummyRule.CB2i { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  CB2i NOT bulk
}
DummyRule.RVi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  RVi NOT bulk
}
DummyRule.APi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  APi NOT bulk
}
DummyRule.PM1i { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  PM1i NOT bulk
}
DummyRule.PM2i { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  PM2i NOT bulk
}
DummyRule.CU_PPI_10UM { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  CU_PPI_10UM NOT bulk
}
DummyRule.CU_PPI_4UM { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  CU_PPI_4UM NOT bulk
}
DummyRule.BJTDUMMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  BJTDUMMY NOT bulk
}
DummyRule.DIODUMMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  DIODUMMY NOT bulk
}
DummyRule.RPDUMMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  RPDUMMY NOT bulk
}
DummyRule.COi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  COi NOT bulk
}
DummyRule.M1i { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  M1i NOT bulk
}
DummyRule.VIA1i { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  VIA1i NOT bulk
}
DummyRule.M2i { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  M2i NOT bulk
}
DummyRule.VIA2i { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  VIA2i NOT bulk
}
DummyRule.M3i { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  M3i NOT bulk
}
DummyRule.VIA3i { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  VIA3i NOT bulk
}
DummyRule.M4i { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  M4i NOT bulk
}
DummyRule.VIA4i { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  VIA4i NOT bulk
}
DummyRule.M5i { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  M5i NOT bulk
}
DummyRule.VIA5i { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  VIA5i NOT bulk
}
DummyRule.M6i { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  M6i NOT bulk
}
DummyRule.M1_PIN_TEXT { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  M1_PIN_TEXT NOT bulk
}
DummyRule.M2_PIN_TEXT { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  M2_PIN_TEXT NOT bulk
}
DummyRule.M3_PIN_TEXT { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  M3_PIN_TEXT NOT bulk
}
DummyRule.M4_PIN_TEXT { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  M4_PIN_TEXT NOT bulk
}
DummyRule.M5_PIN_TEXT { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  M5_PIN_TEXT NOT bulk
}
DummyRule.M6_PIN_TEXT { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  M6_PIN_TEXT NOT bulk
}
DummyRule.VIADi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  VIADi NOT bulk
}
DummyRule.MDi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  MDi NOT bulk
}
DummyRule.CBi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  CBi NOT bulk
}
DummyRule.CBDi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  CBDi NOT bulk
}
DummyRule.UBMi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  UBMi NOT bulk
}
DummyRule.PPIi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  PPIi NOT bulk
}
DummyRule.RPOi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  RPOi NOT bulk
}
DummyRule.NTNi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  NTNi NOT bulk
}
DummyRule.PLMIDEi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  PLMIDEi NOT bulk
}
DummyRule.DNWi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  DNWi NOT bulk
}
DummyRule.VTMPi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  VTMPi NOT bulk
}
DummyRule.VTMNi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  VTMNi NOT bulk
}
DummyRule.PV_P { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  PV_P NOT bulk
}
DummyRule.PV_N { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  PV_N NOT bulk
}
DummyRule.HRIi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  HRIi NOT bulk
}
DummyRule.M1DMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  M1DMY NOT bulk
}
DummyRule.M2DMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  M2DMY NOT bulk
}
DummyRule.M3DMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  M3DMY NOT bulk
}
DummyRule.M4DMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  M4DMY NOT bulk
}
DummyRule.M5DMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  M5DMY NOT bulk
}
DummyRule.M6DMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  M6DMY NOT bulk
}
DummyRule.MDDMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  MDDMY NOT bulk
}
DummyRule.M1SLOTi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  M1SLOTi NOT bulk
}
DummyRule.M2SLOTi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  M2SLOTi NOT bulk
}
DummyRule.M3SLOTi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  M3SLOTi NOT bulk
}
DummyRule.M4SLOTi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  M4SLOTi NOT bulk
}
DummyRule.M5SLOTi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  M5SLOTi NOT bulk
}
DummyRule.M6SLOTi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  M6SLOTi NOT bulk
}
DummyRule.MDSLOTi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  MDSLOTi NOT bulk
}
DummyRule.CTM1i { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  CTM1i NOT bulk
}
DummyRule.CTM2i { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  CTM2i NOT bulk
}
DummyRule.CTM3i { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  CTM3i NOT bulk
}
DummyRule.CTM4i { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  CTM4i NOT bulk
}
DummyRule.CTM5i { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  CTM5i NOT bulk
}
DummyRule.HOTWL { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  HOTWL NOT bulk
}
DummyRule.EXCLi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  EXCLi NOT bulk
}
DummyRule.DRCDMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  DRCDMY NOT bulk
}
DummyRule.RWDMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  RWDMY NOT bulk
}
DummyRule.DPDMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  DPDMY NOT bulk
}
DummyRule.PLDMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  PLDMY NOT bulk
}
DummyRule.SDI { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  SDI NOT bulk
}
DummyRule.ESD1DMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  ESD1DMY NOT bulk
}
DummyRule.ESD2DMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  ESD2DMY NOT bulk
}
DummyRule.ESD3DMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  ESD3DMY NOT bulk
}
DummyRule.CTMDMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  CTMDMY NOT bulk
}
DummyRule.RLPPDMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  RLPPDMY NOT bulk
}
DummyRule.DMN2V { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  DMN2V NOT bulk
}
DummyRule.DMP2V { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  DMP2V NOT bulk
}
DummyRule.VARDMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  VARDMY NOT bulk
}
DummyRule.PMDMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  PMDMY NOT bulk
}
DummyRule.FWi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  FWi NOT bulk
}
DummyRule.LMARK { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  LMARK NOT bulk
}
DummyRule.LWI { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  LWI NOT bulk
}
DummyRule.WBDMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  WBDMY NOT bulk
}
DummyRule.ESDi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  ESDi NOT bulk
}
DummyRule.ESDIMPi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  ESDIMPi NOT bulk
}
DummyRule.INDDMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  INDDMY NOT bulk
}
DummyRule.SEALRING { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  SEALRING NOT bulk
}
DummyRule.LOGO { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  LOGO NOT bulk
}
DummyRule.LUPWDMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  LUPWDMY NOT bulk
}
DummyRule.VDDDMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  VDDDMY NOT bulk
}
DummyRule.VSSDMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  VSSDMY NOT bulk
}
DummyRule.TSVi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  TSVi NOT bulk
}
DummyRule.DM1EXCL { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  DM1EXCL NOT bulk
}
DummyRule.DM2EXCL { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  DM2EXCL NOT bulk
}
DummyRule.DM3EXCL { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  DM3EXCL NOT bulk
}
DummyRule.DM4EXCL { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  DM4EXCL NOT bulk
}
DummyRule.DM5EXCL { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  DM5EXCL NOT bulk
}
DummyRule.DM6EXCL { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  DM6EXCL NOT bulk
}
DummyRule.DMDEXCL { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  DMDEXCL NOT bulk
}
#ENDIF
			

// *********************************************
// begin pre-generation process : find open area
// *********************************************
#IFDEF UseprBoundary
  bulk_pre = COPY prBoundary
#ELSE
#IFDEF ChipWindowUsed
  POLYGON xLB yLB xRT yRT ChipWindow
  bulk_pre = PUSH ChipWindow
#ELSE
  bulk_ext = EXTENT
  bulk_pre = PUSH bulk_ext
#ENDIF 
#ENDIF

#IFDEF WithSealring
  bulk = SIZE bulk_pre BY -(SRwidth + grid)
#ELSE
  bulk = COPY bulk_pre
#ENDIF  

#IFDEF dmOnCorner
  CHIP = SIZE bulk BY -(dm2Chip + grid)
#ELSE
// for seal-ring and chip corner excluding regions, no dummy on chip corner.
  #IFDEF BigDieCorner
  // big die shape  
	#IFDEF RFSWITCH
    EMPTY_AREA = INT bulk < 74 ABUT == 90 REGION INTERSECTING ONLY
	#ELSE 
	  EMPTY_AREA = INT bulk < 350 ABUT == 90 REGION INTERSECTING ONLY
	#ENDIF
  #ELSE
  // small die shape    
	#IFDEF RFSWITCH
        EMPTY_AREA = INT bulk < 74 ABUT == 90 REGION INTERSECTING ONLY
	#ELSE 
	  EMPTY_AREA = INT bulk < 125 ABUT == 90 REGION INTERSECTING ONLY
	#ENDIF
  #ENDIF
  CHIP = SIZE (bulk NOT EMPTY_AREA) BY -(dm2Chip + grid)
#ENDIF

//******* Blockage layers pre-defined **********************************
ODx = SIZE ODi BY (dm2OD + grid) 
POx = SIZE POLYi BY (dm2PO + grid) 
ODBLKx = SIZE ODBLK BY (dm2ODBLK + grid)	// blocking DOD only
POBLKx = SIZE POBLK BY (dm2POBLK + grid) 	// blocking DPO only

NW1 = SIZE NWELi BY -(dm2NW + grid)
NW2 = SIZE NWELi BY (dm2NW + grid) 
NWx = NW2 NOT NW1				// blocking DOD only
FWx = SIZE FWi BY (dm2FW+grid)
HV_ALL =((((( HVOXi OR HVDMYi ) OR HV60DMY ) OR NLVTi ) OR HVNWi) OR BIAS25VNDMY) OR HVSHNi
HVx = SIZE HV_ALL BY (dm2HV + grid)		// blocking HV area
TSVx = SIZE TSVi BY (dm2TSV + grid)		// blocking TSV area
DTx = SIZE DTi BY (dm2DT + grid)		// blocking DT area
LOGOx = SIZE LOGO BY (dm2LOGO + grid)		// blocking LOGO area
FLASHx = SIZE FLASH BY (dm2FLASH + grid)	// blocking em-flash area    
BJTDUMMYx = SIZE BJTDUMMY BY (dm2BJTDUMMY + grid)	// blocking em-flash area    
BPM2  = SIZE CTM2i BY 2 INSIDE OF M2i STEP 0.28*0.7 TRUNCATE 0.28*0.7	// CBM = TCTM SIZE 2
BPM3  = SIZE CTM3i BY 2 INSIDE OF M3i STEP 0.28*0.7 TRUNCATE 0.28*0.7	// CBM = TCTM SIZE 2
BPM4  = SIZE CTM4i BY 2 INSIDE OF M4i STEP 0.28*0.7 TRUNCATE 0.28*0.7	// CBM = TCTM SIZE 2
BPM5  = SIZE CTM5i BY 2 INSIDE OF M5i STEP 0.28*0.7 TRUNCATE 0.28*0.7	// CBM = TCTM SIZE 2
CBM_ALL = (( BPM2 OR BPM3 ) OR BPM4 ) OR BPM5  
    
CBMx = SIZE CBM_ALL BY (dm2CBM + grid)		// blocking CBM for MIMCAP area    
LMARKx = SIZE LMARK BY (dm2LMARK + grid) 
NWDMYx = SIZE RWDMY BY (dm2NWDMY + grid) 	// blocking DOD only
INDDMYx = SIZE INDDMY BY (dm2INDDMY + grid) 
// DOD/DPO blocking

#IFDEF REVISE_DOD
#IFDEF REVISE_DPO
NFILL = COPY bulk	// wrong setting, output nothing
#ELSE
NFILL = ((((ODx OR POx) OR FWx) OR LMARKx) OR INDDMYx) OR LOGOx
#ENDIF
#ELSE
NFILL = ((((ODx OR POx) OR FWx) OR LMARKx) OR INDDMYx) OR LOGOx
#ENDIF

#IFDEF dmOnCBM
#IFDEF RFSWITCH
DOD_BLK = (((((ODBLKx OR NWx) OR NWDMYx) OR NFILL) OR HVx) OR TSVx) OR DTx
DPO_BLK = (((POBLKx OR NFILL) OR HVx) OR TSVx) OR DTx
#ELSE
DOD_BLK = (((((((ODBLKx OR NWx) OR NWDMYx) OR NFILL) OR HVx) OR TSVx) OR DTx) OR FLASHx) OR BJTDUMMYx
DPO_BLK = (((((POBLKx OR NFILL) OR HVx) OR TSVx) OR DTx) OR FLASHx) OR BJTDUMMYx
#ENDIF
#ELSE
#IFDEF RFSWITCH
DOD_BLK = ((((((ODBLKx OR NWx) OR NWDMYx) OR NFILL) OR HVx) OR TSVx) OR DTx) OR CBMx
DPO_BLK = ((((POBLKx OR NFILL) OR HVx) OR TSVx) OR DTx) OR CBMx
#ELSE
DOD_BLK = ((((((((ODBLKx OR NWx) OR NWDMYx) OR NFILL) OR HVx) OR TSVx) OR DTx) OR FLASHx) OR BJTDUMMYx) OR CBMx
DPO_BLK = ((((((POBLKx OR NFILL) OR HVx) OR TSVx) OR DTx) OR FLASHx) OR BJTDUMMYx) OR CBMx
#ENDIF
#ENDIF

#ENCRYPT


#IFDEF REVISE_DOD
dpo_ori1 = RECTANGLE DPO == DpoL1 BY == DpoW1	// look for utility inserted big DPO
dpo1_l1 = GROW dpo_ori1 LEFT BY (dm2dm1 + DodW1) 
dpo1_l2 = GROW dpo_ori1 LEFT BY dm2dm1
dod1_lx = ((dpo1_l1 NOT dpo1_l2) OUTSIDE DOD_BLK) NOT INTERACT DPO // generate DOD from DPO
dod1_l = RECTANGLE dod1_lx == DodW1 BY == DodW1

dpo_ori2 = RECTANGLE DPO == DpoL2 BY == DpoW2	// look for utility inserted small DPO
dpo2_l1 = GROW dpo_ori2 LEFT BY (dm2dm2 + DodW2) 
dpo2_l2 = GROW dpo_ori2 LEFT BY dm2dm2
dod2_lx = ((dpo2_l1 NOT dpo2_l2) OUTSIDE DOD_BLK) NOT INTERACT DPO // generate DOD from DPO
dod2_l = RECTANGLE dod2_lx == DodW2 BY == DodW2

dod_revx = (dod1_l NOT INTERACT dod2_l) OR dod2_l
dod_rev2rev = EXT dod_revx < Dod2DOD ABUT SINGULAR REGION
dod_rev2DOD = EXT dod_revx DOD < Dod2DOD ABUT OVERLAP SINGULAR REGION
dod_rev2DOD_1 = dod_revx AND DOD
dod_rev2DPO = EXT dod_revx DPO < Dpo2DOD ABUT OVERLAP SINGULAR REGION
dod_rev2DPO_1 = dod_revx AND DPO
dod_rev = dod_revx NOT INTERACT ((((dod_rev2rev OR dod_rev2DOD) OR dod_rev2DPO) OR dod_rev2DOD_1) OR dod_rev2DPO_1) // Revised DOD

DODx = DOD OR dod_rev
Dod2DODx = SIZE DODx BY (Dod2DOD + grid) 	// for following insertion
Dod2DPOx = SIZE DPO BY (Dpo2DOD + grid) 
Dpo2DODx = SIZE DODx BY (Dpo2DOD + grid) 
Dpo2DPOx = SIZE DPO BY (Dpo2DPO + grid)
#ELSE
#IFDEF REVISE_DPO
dod_ori1 = RECTANGLE DOD == DodW1 BY == DodW1	// look for utility inserted big DOD
dod1_r1 = GROW dod_ori1 RIGHT BY (dm2dm1 + DpoW1) 
dod1_r2 = GROW dod_ori1 RIGHT BY dm2dm1
dpo1_r = ((dod1_r1 NOT dod1_r2) OUTSIDE DPO_BLK) NOT INTERACT DOD

dod_ori2 = RECTANGLE DOD == DodW2 BY == DodW2	// look for utility inserted small DOD
dod2_r1 = GROW dod_ori2 RIGHT BY (dm2dm2 + DpoW2) 
dod2_r2 = GROW dod_ori2 RIGHT BY dm2dm2
dpo2_r = ((dod2_r1 NOT dod2_r2) OUTSIDE DPO_BLK) NOT INTERACT DOD

dod1_t1 = GROW dod_ori1 TOP BY (dm2dm1 + DpoW1) 
dod1_t2 = GROW dod_ori1 TOP BY dm2dm1
dpo1_t = ((dod1_t1 NOT dod1_t2) OUTSIDE DPO_BLK) NOT INTERACT DOD

dod2_t1 = GROW dod_ori2 TOP BY (dm2dm2 + DpoW2) 
dod2_t2 = GROW dod_ori2 TOP BY dm2dm2
dpo2_t = ((dod2_t1 NOT dod2_t2) OUTSIDE DPO_BLK) NOT INTERACT DOD

dpo_revx1 = dpo1_r OR dpo1_t
dpo_revx2 = dpo2_r OR dpo2_t
dpo_revx = (dpo_revx1 NOT INTERACT dpo_revx2) OR dpo_revx2
dpo_rev2DOD = EXT dpo_revx DOD < Dpo2DOD ABUT OVERLAP SINGULAR REGION
dpo_rev2DOD_1 = dpo_revx AND DOD
dpo_rev2rev = EXT dpo_revx < Dpo2DPO ABUT SINGULAR REGION
dpo_rev2DPO = EXT dpo_revx DPO < Dpo2DPO ABUT OVERLAP SINGULAR REGION
dpo_rev2DPO_1 = dpo_revx AND DPO
dpo_rev = dpo_revx NOT INTERACT ((((dpo_rev2DOD OR dpo_rev2rev) OR dpo_rev2DPO) OR dpo_rev2DOD_1) OR dpo_rev2DPO_1) // Revised DPO

DPOx = DPO OR dpo_rev
Dod2DODx = SIZE DOD BY (Dod2DOD + grid) 
Dod2DPOx = SIZE DPOx BY (Dpo2DOD + grid) 
Dpo2DODx = SIZE DOD BY (Dpo2DOD + grid) 
Dpo2DPOx = SIZE DPOx BY (Dpo2DPO + grid)
#ELSE
Dod2DODx = SIZE DOD BY (Dod2DOD + grid) 
Dod2DPOx = SIZE DPO BY (Dpo2DOD + grid) 
Dpo2DODx = SIZE DOD BY (Dpo2DOD + grid) 
Dpo2DPOx = SIZE DPO BY (Dpo2DPO + grid)
#ENDIF
#ENDIF

DOD_EXC = (DOD_BLK OR Dod2DODx) OR Dod2DPOx
DPO_EXC = (DPO_BLK OR Dpo2DPOx) OR Dpo2DODx
// Big pattern DOD/DPO -- 1

frame1 	= CHIP NOT NFILL 
frameL 	= RECTANGLES (cell1 - grid) (cell1 - grid) grid INSIDE OF LAYER frame1

frameL_DOD = FLATTEN(frameL OUTSIDE DOD_EXC)	// prevent the rotation of cell placement

#IFDEF REVISE_DPO
frameL_DPO = FLATTEN(frameL OUTSIDE DPO_EXC)
#ELSE
#IFDEF ADD_DPO_ALSO
frameL_DPO = FLATTEN(frameL OUTSIDE DPO_EXC)
#ENDIF  
#ENDIF  

#IFNDEF REVISE_DPO
dod1   	= RECTANGLES DodW1 DodW1 DodS1 INSIDE OF LAYER frameL_DOD
#ENDIF  
#IFDEF REVISE_DPO
tpo1h  	= RECTANGLES DpoL1 DpoW1 DpoSX1 DpoSY1 INSIDE OF LAYER frameL_DPO
tpo1v  	= RECTANGLES DpoW1 DpoL1 DpoSY1 DpoSX1 INSIDE OF LAYER frameL_DPO	
dpo1h  	= SHIFT tpo1h BY 0 DodW1+dm2dm1
dpo1v  	= SHIFT tpo1v BY DodW1+dm2dm1 0
#ELSE
#IFDEF ADD_DPO_ALSO
tpo1h  	= RECTANGLES DpoL1 DpoW1 DpoSX1 DpoSY1 INSIDE OF LAYER frameL_DPO
tpo1v  	= RECTANGLES DpoW1 DpoL1 DpoSY1 DpoSX1 INSIDE OF LAYER frameL_DPO	
dpo1h  	= SHIFT tpo1h BY 0 DodW1+dm2dm1
dpo1v  	= SHIFT tpo1v BY DodW1+dm2dm1 0
#ENDIF  
#ENDIF  

// Small pattern cell -- 2
space1	= frame1 NOT (SIZE frameL BY grid)
frameS1 = RECTANGLES (cell2 - grid) (cell2 - grid) grid INSIDE OF LAYER space1

// Small pattern cell -- 3
space2	= space1 NOT (SIZE frameS1 BY grid)
frameS2 = RECTANGLES (cell2 - grid) (cell2 - grid) grid INSIDE OF LAYER space2

// Small pattern cell -- 4
space3	= space2 NOT (SIZE frameS2 BY grid)
frameS3 = RECTANGLES (cell2 - grid) (cell2 - grid) grid INSIDE OF LAYER space3

// Small pattern cell -- 5 
space4	= space3 NOT (SIZE frameS3 BY grid)
frameS4 = RECTANGLES (cell2 - grid) (cell2 - grid) grid INSIDE OF LAYER space4

// Small pattern cell -- 6
space5	= space4 NOT (SIZE frameS4 BY grid)
frameS5 = RECTANGLES (cell2 - grid) (cell2 - grid) grid INSIDE OF LAYER space5

frameS = (((frameS1 OR frameS2) OR frameS3) OR frameS4) OR frameS5

frameS_DOD = FLATTEN(frameS OUTSIDE DOD_EXC)
frameS_DPO = FLATTEN(frameS OUTSIDE DPO_EXC)

// Create small pattern DOD/DPO

#IFNDEF REVISE_DPO
dod2    = RECTANGLES DodW2 DodW2 DodS2 INSIDE OF LAYER frameS_DOD
#ENDIF  
#IFDEF REVISE_DPO
tpo2h   = RECTANGLES DpoL2 DpoW2 DpoSX2 DpoSY2 INSIDE OF LAYER frameS_DPO
tpo2v   = RECTANGLES DpoW2 DpoL2 DpoSY2 DpoSX2 INSIDE OF LAYER frameS_DPO
dpo2h  	= SHIFT tpo2h BY 0 DodW2+dm2dm2
dpo2v  	= SHIFT tpo2v BY DodW2+dm2dm2 0
#ELSE
#IFDEF ADD_DPO_ALSO
tpo2h   = RECTANGLES DpoL2 DpoW2 DpoSX2 DpoSY2 INSIDE OF LAYER frameS_DPO
tpo2v   = RECTANGLES DpoW2 DpoL2 DpoSY2 DpoSX2 INSIDE OF LAYER frameS_DPO
dpo2h  	= SHIFT tpo2h BY 0 DodW2+dm2dm2
dpo2v  	= SHIFT tpo2v BY DodW2+dm2dm2 0
#ENDIF  
#ENDIF  

#ENDCRYPT    

#IFDEF MIXED_SCHEME  // MIXED_SCHEME

#IFNDEF REVISE_DPO
GEN_DOD {
#IFDEF REVISE_DOD
  (dod1 OR dod2) OR dod_rev
#ELSE
  dod1 OR dod2 
#ENDIF  
}
DRC CHECK MAP GEN_DOD 3 1 AREF DOD_1 DodW1 DodW1 AREF DOD_2 DodW2 DodW2 	// Dummy OD

#ENDIF

#IFNDEF REVISE_DOD
#IFDEF REVISE_DPO
GEN_DPO {
  (((dpo1h OR dpo1v) OR dpo2h) OR dpo2v) OR dpo_rev
}
DRC CHECK MAP GEN_DPO 13 1 AREF DPO_1 DpoL1 DpoW1 AREF DPO_2 DpoL2 DpoW2 	// Dummy POLY
#ELSE
#IFDEF ADD_DPO_ALSO
GEN_DPO {
  ((dpo1h OR dpo1v) OR dpo2h) OR dpo2v
}
DRC CHECK MAP GEN_DPO 13 1 AREF DPO_1 DpoL1 DpoW1 AREF DPO_2 DpoL2 DpoW2 	// Dummy POLY
#ENDIF
#ENDIF

#ENDIF

#ELSE  // ELSE OF MIXED_SCHEME

#IFNDEF REVISE_DPO
GEN_DOD {
#IFDEF REVISE_DOD
  (dod1 OR dod2) OR dod_rev
#ELSE
  dod1 OR dod2 
#ENDIF  
}
DRC CHECK MAP GEN_DOD 3 0 AREF DOD_1 DodW1 DodW1 AREF DOD_2 DodW2 DodW2 	// Dummy OD

#ENDIF

#IFNDEF REVISE_DOD
#IFDEF REVISE_DPO
GEN_DPO {
  (((dpo1h OR dpo1v) OR dpo2h) OR dpo2v) OR dpo_rev
}
DRC CHECK MAP GEN_DPO 13 0 AREF DPO_1 DpoL1 DpoW1 AREF DPO_2 DpoL2 DpoW2 	// Dummy POLY
#ELSE
#IFDEF ADD_DPO_ALSO
GEN_DPO {
  ((dpo1h OR dpo1v) OR dpo2h) OR dpo2v
}
DRC CHECK MAP GEN_DPO 13 0 AREF DPO_1 DpoL1 DpoW1 AREF DPO_2 DpoL2 DpoW2 	// Dummy POLY
#ENDIF
#ENDIF

#ENDIF

#ENDIF // END OF MIXED_SCHEME

//---------------
// End Generation
//---------------

