//****************************************************************************************
// CALIBRE DUMMY METAL INSERTION UTILITY - Dummy_Metal_Calibre_0.18um.214a (01/13/2017) *
// FOR TSMC 0.18UM TECHNOLOGY 1P6M PROCESS                                               *
// (DESIGN RULE DOCUMENT:           T-018-LO-DR-001  Rev 2.14a)							 *
// (UTILITY DOCUMENT:               T-018-LO-DR-001-C3 Rev 2.14a) 			             *
//****************************************************************************************



//************************************************************************************
//* TSMC developed this deck using Mentor Graphics proprietary SVRF and TVF formats.
//* The deck is to be used only in Calibre tools.
//************************************************************************************
//
//  DISCLAIMER
//
//  The information contained herein is provided by TSMC on an "AS IS" basis
//  without any warranty, and TSMC has no obligation to support or otherwise
//  maintain the information.  TSMC disclaims any representation that the
//  information does not infringe any intellectual property rights or proprietary
//  rights of any third parties.  There are no other warranties given by TSMC,
//  whether express, implied or statutory, including, without limitation, implied
//  warranties of merchantability and fitness for a particular purpose.
//
//  STATEMENT OF USE
//
//  This information contains confidential and proprietary information of TSMC.
//  No part of this information may be reproduced, transmitted, transcribed,
//  stored in a retrieval system, or translated into any human or computer
//  language, in any form or by any means, electronic, mechanical, magnetic,
//  optical, chemical, manual, or otherwise, without the prior written permission
//  of TSMC.  This information was prepared for informational purpose and is for
//  use by TSMC's customers only.  TSMC reserves the right to make changes in the
//  information at any time and without notice.
//
//-------------------------------------------------------------------------------------------
//
//  NOTICE: (Read Me First!)
//
//  1. If the input GDS file does not include all the layers in the
//     INPUT LAYER BLOCK, for example, they are generated by logic
//     operations, please make sure the consistence with original
//     layer definition.
//
//  2. The runset is tested and developed on Calibre v2010.4_26.16 (Dec. 2010), please use 
//     this or newer TSMC qualified version of Calibre to execute this runset.
//
//*******************************************************************************
//      CORRECT USAGE: 								 
//*******************************************************************************
//
// The following options are very important, user needs to turn on or turn off	 
// the options according to their application.					 
//										 
//  (1) #DEFINE ChipWindowUsed : (default is commented and disabled)
//	The utility will use the boundary generated by defined (tape-out) layers
//	for the insertion by default.
//	If customers want to specified the window of chip exactly, please un-comment
//	the line as below:
//
//		#DEFINE ChipWindowUsed 
//
//	Then modifiy the Variables ( xLB, yLB ) for the coordinate of left-bottom corner
//	and ( xRT, yRT ) for the coordinate of right-top corner of the user-defined chip window
//	Moreover, the line below is an un-used layer number for constructing the chip window
//
//		LAYER ChipWindow 500
//
//	If layer number 500 is used, please assign another layer number without conflict.
//
//  (2) #DEFINE dmOnCorner : (default is commented and disabled)			 
//	By default, The utility will not insert dummy layers in the chip corners and 
//	reserve the space for sealring.
//	If customers want to add dummy inside whole layout extent like sub-cell or macro
//	level applications. Please un-comment the line as below:
//
//		#DEFINE dmOnCorner
//
//	For cell and macro level layout, please turn on "dmOnCorner" to insert dummy on corner. 
//
//  (3) #DEFINE BigDieCorner : (default is enabled)			 
//	This option only effective when "dmOnCorner" is disabled. By default, the shape
//	of the chip corner is big-die style. 
//	If the chip size is small and customers need the small-die shape of chip corner.
//	Please comment the line as below:
//
//		//#DEFINE BigDieCorner
//
//  (4) #DEFINE WithSealring : (default is commented and disabled)		
//	By default, this option is disabled for layout without sealring structure. 
//	If the target layout for dummy pattern insertion already has the sealring, 
//	users need to enable this option. The dummy patterns would be only inserted 
//	inside the region that was shrinked "20um" inward. This could solve the overlap 
//	between dummy patterns and CDU regions.
//	Please un-comment the line as below to enable this option:
//    
//		#DEFINE WithSealring
//
//  (5) #DEFINE FILL_Mx : (default is enabled for M1 to M6, disabled for MD)
//	By default, the utility will insert dummy patterns according from M1 to M6.
//	Customers could comment the line as below to prevent from insertion of Mx:
//
//		//#DEFINE FILL_Mx
//  (6) #DEFINE THICK_Mx : (default is commented and disabled)
//	Customers could enable this option for top metals for employ 20K thick metal spec
//      or 9K thick metal spec.
//	To enable this function, please un-comment the line as below:
//
//	  #DEFINE THICK_Mx
//
//  (7) #DEFINE THICK_30K_Mx : (default is commented and disabled)
//	Customers could enable this option for top metals for employ 30K thick metal spec
//	To enable this function, please un-comment the line as below:
//
//		#DEFINE THICK_30K_Mx
//
//  (8) #DEFINE THICK_40K_Mx : (default is commented and disabled)
//	Customers could enable this option for top metals for employ 40K thick metal spec
//	To enable this function, please un-comment the line as below:
//
//      #DEFINE THICK_40K_Mx
//
//  (9) #DEFINE CTM_OVER_Mx : (default is commented)	
//	Regions under the CTM will not insert dummy metal. If there is capacitor structure
//	in the design, please select this option properly. For example, if the capacitor
//	structure located between M5 and M6, ONLY CTM_OVER_M5 should be enabled and regions
//	under the CBM will not insert dummy metal M5.
//	Customers could enable this option by un-commented the line as follow:
//
//		#DEFINE CTM_OVER_Mx
//

//  (10) #DEFINE MIXED_SCHEME : (default is commented and disabled)
//	By default, the output datatype of generated dummy metal patterns are set to 
//	"0" (drawing) and then the inserted dummy patterns will be taken as drawing layer in
//	design rule checking (DRC). If the option is turned on, the output datatye of generated
//	patterns will be set to "1" (dummy) and DRC will not check the inserted dummmy patterns.
//
//		#DEFINE MIXED_SCHEME
//
//  (11) #DEFINE RFSWITCH : 
//	Customers could enable this option for RFSWITCH process
//	To enable this function, please un-comment the line as below:
//
//     #DEFINE RFSWITCH
//
//  (12) #DEFINE SealringNonCSR SWITCH : 
//	It's only for RFSWITCH. Customers could enable this option for Sealring Without CSR structure.
//	To enable this function, please un-comment the line as below:
//
//      #DEFINE SealringNonCSR  

//*******************************************************************************
//      NOTE:
//*******************************************************************************
// If this utility was used for cell level design, below options or variable need to take care.
//
// 1. Cell boundary: turn on option "ChipWindowUsed" to define cell boundary or use whole layout extent.
// 2. Dummy on cell corner: turn on option "dmOnCorner" to insert dummy on cell corner.
// 3. Dummy to cell boundary: variable "dm2Chip" defines min. space between dummy and boundary,
//    user can revise this variable to change the space between dummy and cell boundary.
//    Please note that dummy metal must be enclosed by chip edge >= 5.0 um.   
//
//*******************************************************************************
//
// REVISION:                                                                 
//
// 2.6a 01/03/2006 Allen Tsai
//	1) Newly created.
//	2) Add LOGO layer. 
// 2.6b 08/14/2006 Allen Tsai
//	1) Modify the description of #DEFINE THICK_Mx
//	2) Modify the space of large DM to real metal space to 5.
// 2.6c_pre 01/17/2007 Y.J. Chuang
//	1) Add TSV to Exclude Layer for dummy Metal insertion.
// 2.6c_pre 11/29/2007 Y.L. Liu
//	1) Change MD size to align MT rules
// 2.7a 05/05/2009 Y.M. Zhang
//	1) Add 30K and 40K UTM dummy metal insertion and related switch.
// 2.8a 10/06/2010 R.H. Zhang
//      1) Added layer HVDMY, HV60DMY, NLVT, HVNW to exclude HV region for dummy metal insertion.
//      2) Added layer FLASH to exclude FLASH region for dummy metal insertion. 
//      3) Added layer BJTDUMMY to exclude BJTDUMMY region for dummy metal insertion. 
// 2.8b_eval 01/16/2012 Franky Chen
//      1) Offer non-encrypt version 
// 2.10a 05/10/2013 Franky Chen
//  1) Add C018 RFSWITCH process
// 2.10b 09/15/2013 X.Yao
//  1) Modify RFSWITCH process top metal dimension
// 2.14a 01/13/2017 L.L. Cao
//  1) Add SealringNonCSR SWITCH only for RFSWITCH application 
//
//*******************************************************************************
//



//
// ENVIRONMENT SETUP
//------------------
PRECISION    1000
RESOLUTION      5    // tool resolution

LAYOUT SYSTEM GDSII
LAYOUT PATH "top_wo_dummy.gds"
LAYOUT PRIMARY "TOP_CHIP_DIG_ANA_BACKUP"
LAYOUT PROCESS BOX RECORD YES

//Please do not stream-in directly if the topcell name is the same as the original one.
DRC RESULTS DATABASE "dummy.gds" GDSII
//DRC RESULTS DATABASE "DM.gds" GDSII _DM
DRC SUMMARY REPORT "DM.sum" 
DRC MAXIMUM RESULTS ALL
DRC KEEP EMPTY NO
//LAYOUT ALLOW DUPLICATE CELL YES // allow multiple records for the same layout cell
//LAYOUT ERROR ON INPUT NO

//******* User defined chip area  **************************************
//  OPTION SETUP
//#DEFINE ChipWindowUsed
VARIABLE xLB   0.0	// x-coordinate of left-bottom corner for user defined chip window 
VARIABLE yLB   0.0	// y-coordinate of left-bottom corner for user defined chip window 
VARIABLE xRT   0.0	// x-coordinate of right-top corner for user defined chip window  
VARIABLE yRT   0.0	// y-coordinate of right-top corner for user defined chip window 
LAYER ChipWindow 500	// layer number for constructing chip boundary

//******* Options for chip corner empty area definition ****************

#DEFINE dmOnCorner	// Allow pattern on chip corner? (apply to cell or macro level)
#DEFINE BigDieCorner	// Corner empty area for big die is used?  
#DEFINE WithSealring	// Already with the sealring structure assembled?
//#DEFINE MIXED_SCHEME	// Set output data type of DMx as "1". The default output data type is "0".
//#DEFINE RFSWITCH 		// for RFSWITCH process
//#DEFINE SealringNonCSR  // Sealring without CSR structure (for RFSWITCH application only)

//******* Select layers to be filled ***********************************
#DEFINE FILL_M1		// turn on to fill dummy metal M1

#DEFINE FILL_M2		// turn on to fill dummy metal M2
#DEFINE CTM_OVER_M2	// regions under the CBM will not insert dummy metal M2

#DEFINE FILL_M3		// turn on to fill dummy metal M3
//#DEFINE THICK_M3  // turn on if design with M3 as 9k or 20k Thick Top Metal,Otherwise,Please turn off it.
//#DEFINE THICK_30K_M3	//turn on if design with M3 as 30k Thick Top Metal,Otherwise,Please turn off it.
//#DEFINE THICK_40K_M3	//turn on if design with M3 as 40k Thick Top Metal,Otherwise,Please turn off it. 
#DEFINE CTM_OVER_M3	// regions under the CBM will not insert dummy metal M3

#DEFINE FILL_M4		// turn on to fill dummy metal M4
//#DEFINE THICK_M4  // turn on if design with M4 as 9k or 20k Thick Top Metal,Otherwise,Please turn off it.
//#DEFINE THICK_30K_M4	//turn on if design with M4 as 30k Thick Top Metal,Otherwise,Please turn off it.
//#DEFINE THICK_40K_M4	//turn on if design with M4 as 40k Thick Top Metal,Otherwise,Please turn off it. 
#DEFINE CTM_OVER_M4	// regions under the CBM will not insert dummy metal M4

#DEFINE FILL_M5		// turn on to fill dummy metal M5
//#DEFINE THICK_M5  // turn on if design with M5 as 9k or 20k Thick Top Metal,Otherwise,Please turn off it.
//#DEFINE THICK_30K_M5	//turn on if design with M5 as 30k Thick Top Metal,Otherwise,Please turn off it.
//#DEFINE THICK_40K_M5	//turn on if design with M5 as 40k Thick Top Metal,Otherwise,Please turn off it. 
#DEFINE CTM_OVER_M5	// regions under the CBM will not insert dummy metal M5

#DEFINE FILL_M6		// turn on to fill dummy metal M6
//#DEFINE THICK_M6  // turn on if design with M6 as 9k or 20k Thick Top Metal,Otherwise,Please turn off it.
//#DEFINE THICK_30K_M6	//turn on if design with M6 as 30k Thick Top Metal,Otherwise,Please turn off it.
#DEFINE THICK_40K_M6	//turn on if design with M6 as 40k Thick Top Metal,Otherwise,Please turn off it. 

#DEFINE FILL_MD	// turn on to fill dummy metal MD

//******* Layer Assignment *********************************************

// DRAWN LAYER DEFINITIONS
//------------------------
LAYER NWELi	2	// Nwell technology
LAYER DIFFi	3	// Active areas
LAYER DOD	1340	// Dummy OD (DIFF)
LAYER MAP 3   DATATYPE 1 1340	// Mapping (3;1) to 1340 for dummy OD
LAYER ODBLK	1350	// DOD blocking for insertion
LAYER MAP 150 DATATYPE 20 1350
LAYER PDIFFi	11	// Active areas
LAYER NDIFFi	12	// Active areas
LAYER OD2i	4	// Define thick gate oxides
LAYER POLYi	13	// Polysilicon gates, interconnect
LAYER DPO	1342	// Dummy Poly
LAYER MAP 13  DATATYPE 1 1342	// Mapping (13;1) to 1342 for dummy PO
LAYER POBLK	1351	// DPO blocking for insertion
LAYER MAP 150 DATATYPE 21 1351
LAYER PPi	7	// P+ S/D imlant
LAYER NPi	8	// N+ S/D imlant

LAYER FLASH	94	// FLASH IP outline
LAYER HVNWi	99	// High voltage NW
LAYER HVOXi	180	// HV region define layer
LAYER HVDMYi	401
LAYER MAP 141 DATATYPE 52 401
LAYER NLVTi	405
LAYER MAP 141 DATATYPE 63 405

LAYER HV60DMY	14170
LAYER MAP 141 DATATYPE 70 14170
LAYER CTMDMYUD	3150
LAYER MAP 131 DATATYPE 50 3150
LAYER RFDUMMYUD	6050
LAYER MAP 160 DATATYPE 50 6050


//SOI layers
LAYER DTi	171	// Deep trench
LAYER DTBLK  2046  // Deep trench block
LAYER MAP 171 DATATYPE 2 2046
LAYER NLD 2040 
LAYER MAP 204 DATATYPE 0 2040
LAYER SOILDi 2041 		// to recognize the Lateral Diode device for SOI process 
LAYER MAP 204 DATATYPE 1 2041
LAYER SOIBTi 2042		// to recognize the BCM(body contact MOS) device for SOI process
LAYER MAP 204 DATATYPE 2 2042
LAYER SOIDRNi 2043
LAYER MAP 204 DATATYPE 3 2043
LAYER SOILGi 2044
LAYER MAP 204 DATATYPE 4 2044
LAYER SOI1Gi 2045
LAYER MAP 204 DATATYPE 5 2045


LAYER CB2i	177	// For BiCMOS passivation-2 opening window
LAYER RVi	188	// Hole of SUTM4 and AP-MD interconnect
LAYER MAP 189 DATATYPE 1 1891
LAYER APi	1891	// AL pad or RDL in SiGe PA and SOI process
LAYER PM1i                 5001	    // Polymide (if drawn)
LAYER MAP 5   DATATYPE 1   5001	    
LAYER PM2i                 5002	    // Polymide (if drawn)
LAYER MAP 5   DATATYPE 2   5002
LAYER CU_PPI_10UM   429           // Cu_PPI_10um interconnection between Polymide1 and Polymide2 for WLCSP
LAYER MAP 42 DATATYPE 9 429
LAYER CU_PPI_4UM   4210           // Cu_PPI_4um interconnection between Polymide1 and Polymide2 for WLCSP
LAYER MAP 42 DATATYPE 10 4210

LAYER BJTDUMMY	49	// BJT dummy layer
LAYER DIODUMMY	56	// Diode dummy layer
LAYER RPDUMMY   54
LAYER COi	15	// Define connection from M1 to S/D and Gate
LAYER M1i	16	// First Metal layer
LAYER VIA1i	17	// Define connection from M2 to M1
LAYER M2i	18	// Second Metal layer
LAYER VIA2i	27	// Define connection from M3 to M2
LAYER M3i	28	// Third Metal layer
LAYER VIA3i	29	// Define connection from M4 to M3
LAYER M4i	31	// Fourth Metal layer
LAYER VIA4i	32	// Define connection from M5 to M4
LAYER M5i	33	// Fifth Metal layer
LAYER VIA5i	39	// Define connection from M6 to M5
LAYER M6i	38	// Sixth Metal layer  
LAYER VIADi	167	// Define connect from MD to Top Metal
LAYER MDi	168	// RDL Metal layer above Top Metal
LAYER CBi	19	// Passivation opening for Bond Pad
LAYER CBDi	169	// Definition of passivation window for bump
LAYER UBMi	170	// Bond Pad definition for RDL
LAYER PPIi	189	// Post Passivation RDL
LAYER RPOi	34	// Salicided Block Layer
LAYER NTNi	129	// Native NMOS blocked implantation
LAYER PLMIDEi	89	// Polymide (if drawn)
//LAYER  FUSEi	235	// Fuse window
LAYER DNWi	82	// Deep N-WELL
LAYER VTMPi	23	// Blocking region of PMOS VT implantation
LAYER VTMNi	24	// Blocking region of NMOS VT implantation
LAYER PV_P	71	// PV_P pmos varactor p+ implant layer
LAYER PV_N	72	// PV_N pmos varactor n+ blocking layer
LAYER HRIi	48	// High Resistor implant


// Dummy Metal layers
//-------------------
LAYER MAP 16  DATATYPE 1 316
LAYER M1DMY	316	// Metal1 dummy (if drawn)
LAYER MAP 18  DATATYPE 1 318
LAYER M2DMY	318	// Metal2 dummy (if drawn)
LAYER MAP 28  DATATYPE 1 329
LAYER M3DMY	329	// Metal3 dummy (if drawn)
LAYER MAP 31  DATATYPE 1 331
LAYER M4DMY	331	// Metal4 dummy (if drawn)
LAYER MAP 33  DATATYPE 1 333
LAYER M5DMY	333	// Metal5 dummy (if drawn)
LAYER MAP 38  DATATYPE 1 338
LAYER M6DMY	338	// Metal6 dummy (if drawn)
LAYER MAP 168 DATATYPE 1 340
LAYER MDDMY	340    	// MD dummy (if drawn)

// Metal Slot layers
//------------------
LAYER MAP 16  DATATYPE 2 321
LAYER M1SLOTi	321	// Metal1 slot (if drawn)
LAYER MAP 18  DATATYPE 2 322
LAYER M2SLOTi	322	// Metal2 slot (if drawn)
LAYER MAP 28  DATATYPE 2 323
LAYER M3SLOTi	323	// Metal3 slot (if drawn)
LAYER MAP 31  DATATYPE 2 324
LAYER M4SLOTi	324	// Metal4 slot (if drawn)
LAYER MAP 33  DATATYPE 2 325
LAYER M5SLOTi	325	// Metal5 slot (if drawn)
LAYER MAP 38  DATATYPE 2 326
LAYER M6SLOTi	326	// Metal6 slot (if drawn)
LAYER MAP 168 DATATYPE 2 328
LAYER MDSLOTi	328	// MD slot (if drawn)

// Capacitor Top Metal Layers
//---------------------------
LAYER MAP 67  DATATYPE 1 256
LAYER CTM1i	256	// Capacitor Top Metal-1

LAYER MAP 67  DATATYPE 2 257
LAYER CTM2i	257	// Capacitor Top Metal-2
LAYER MAP 67  DATATYPE 3 258
LAYER CTM3i	258	// Capacitor Top Metal-3
LAYER MAP 67  DATATYPE 4 259
LAYER CTM4i	259	// Capacitor Top Metal-4
LAYER MAP 67  DATATYPE 5 260
LAYER CTM5i	260	// Capacitor Top Metal-5

// Dummy Layers
//-------------
LAYER HOTWL	51	// Hot N-Well (SEE README HOT_NWEL NOTES)
LAYER EXCLi	55	// Exclude layer
LAYER DRCDMY	60	// DRC I/O waiver
LAYER RWDMY	52	// NWEL Resistor dummy layer
LAYER DPDMY	65	// Dummy Pad area dummy layer
LAYER PLDMY	66	// Power Line area dummy layer
LAYER SDI	58	// IO ESD region dummy layer
LAYER ESD1DMY	136	// IO ESD region dummy layer, RPO must enclose whole gate
LAYER ESD2DMY	137	// IO ESD region dummy layer, RPO enclose gate 0.05 for 3.3V
LAYER ESD3DMY	234
LAYER CTMDMY	131	// Cover metal as a capacitor bottom plate
LAYER RLPPDMY	134	// HRI high Poly resistor dummy layer
LAYER DMN2V	184	// Dummy layer to ensure N2V in N+ poly/OD resistor
LAYER DMP2V	149	// Dummy layer to ensure P2V in P+ poly/OD resistor
LAYER VARDMY	138	// Dummy layer to cover varactor device
LAYER PMDMY	236	// Dummy layer to cover fuse window and protection ring structur
LAYER FWi	235	// Fuse window when x, (x+1) = 3 
LAYER LMARK	263	// L target window for bump process
LAYER MAP 63  DATATYPE 1 263
LAYER LWI	363	// L target window for bump process
LAYER MAP 63  DATATYPE 2 363
LAYER WBDMY	183	// Dummy layer to cover the CUP pad
LAYER ESDi	30	// For 0.18um 1.8V/5V on i/o esd's implant only.
LAYER ESDIMPi 2504 // For 0.18um 3.3V esd NMOS only.
LAYER MAP 250 DATATYPE 4 2504
LAYER INDDMY	364	// Dummy layer to define inductor
LAYER MAP 139 DATATYPE 0 364
LAYER SEALRING	126	// SEAL-RING Layer used for SR.S.1 check
LAYER LOGO	178	// Dummy layer for product labels and LOGO
LAYER LUPWDMY     2551     // DRC dummy layer to waive Latch-Up rules for verified IP.
LAYER MAP 255 DATATYPE 1 2551
LAYER MAP 255 DATATYPE 4   2554
LAYER	VDDDMY 2554
LAYER MAP 255 DATATYPE 5   2555
LAYER	VSSDMY 2555
LAYER TSVi    251      // TSV region define layer.


LAYOUT TOP LAYER M1i VIA1i M1SLOTi M1DMY
LAYOUT TOP LAYER M2i VIA2i M2SLOTi M2DMY
LAYOUT TOP LAYER M3i VIA3i M3SLOTi M3DMY
LAYOUT TOP LAYER M4i VIA4i M4SLOTi M4DMY
LAYOUT TOP LAYER M5i VIA5i M5SLOTi M5DMY

LAYOUT TOP LAYER MDi VIADi MDSLOTi MDDMY M6i M6SLOTi M6DMY CBi 

M1xd = (M1i OR M1DMY) NOT M1SLOTi
M1x  = M1i NOT M1SLOTi
LAYER DM1EXCL	371
LAYER MAP 150 DATATYPE 1 371
M2xd = (M2i OR M2DMY) NOT M2SLOTi
M2x  = M2i NOT M2SLOTi
LAYER DM2EXCL	372
LAYER MAP 150 DATATYPE 2 372
M3xd = (M3i OR M3DMY) NOT M3SLOTi
M3x  = M3i NOT M3SLOTi
LAYER DM3EXCL	373
LAYER MAP 150 DATATYPE 3 373
M4xd = (M4i OR M4DMY) NOT M4SLOTi
M4x  = M4i NOT M4SLOTi
LAYER DM4EXCL	374
LAYER MAP 150 DATATYPE 4 374
M5xd = (M5i OR M5DMY) NOT M5SLOTi
M5x  = M5i NOT M5SLOTi
LAYER DM5EXCL	375
LAYER MAP 150 DATATYPE 5 375
M6xd = (M6i OR M6DMY) NOT M6SLOTi
M6x  = M6i NOT M6SLOTi
LAYER DM6EXCL	376
LAYER MAP 150 DATATYPE 6 376
MDxd = (MDi OR MDDMY) NOT MDSLOTi
MDx  = MDi NOT MDSLOTi
LAYER DMDEXCL	380
LAYER MAP 150 DATATYPE 15 380

ODi  = (DIFFi OR NDIFFi) OR PDIFFi



//******* Variables do not be modified *********************************

VARIABLE grid		0.005	// official grid size
VARIABLE midM		1.0	// metal filtering size
VARIABLE SRwidth	20.0	// width of sealring including CDU and isolation regions 

//******* Density Definitions (Same for all layers M1 - M6) ************
VARIABLE WindowSize	200	// density check window 		
VARIABLE WindowStep	100	// movement of density check window
VARIABLE emptyWindowSize 10	// empty window size		
VARIABLE emptyWindowStep 10	// movement of empty window

//******* Fill region and spacing definitions **************************

VARIABLE excludeHoleSize 4	// exclude insertion when hole width less than this value 
VARIABLE dm2FW		5.0	// dummy to FW layer spacing 		
VARIABLE dm2LMARK	5.0	// dummy to LMARK layer spacing 	
VARIABLE dm2DMEXCL	4.0	// dummy to blockage layer spacing
#IFDEF RFSWITCH
VARIABLE dm2LOGO	0.0	// dummy to LOGO spacing
VARIABLE dm2INDDMY	0.0	// dummy to INDDMY spacing
#ELSE
VARIABLE dm2LOGO	3.0	// dummy to LOGO spacing
VARIABLE dm2INDDMY	20.0	// dummy to INDDMY spacing
#ENDIF
VARIABLE dm2CBM		5.0	// dummy to capacitor bottom plate spacing
VARIABLE dm2Chip	5.0	// dummy to Chip Edge spacing 	
VARIABLE dm2HV	10.0	// dummy to HV area
VARIABLE dm2FLASH	10.0	// dummy to em-flash area
VARIABLE dm2BJTDUMMY	10.0	// dummy to BJTDUMMY area
VARIABLE dm2TSV		70.0	// dummy to TSV area
//******* Fill dimension & offset & density constraints ****************
VARIABLE dmW_M1		0.6	// small DM1 width   
VARIABLE dmL_M1		0.6	// small DM1 length  
VARIABLE dmS_M1		0.6	// small DM1 spacing   
VARIABLE dm2M1		1.2	// small DM1 to real metal spacing 	
VARIABLE MdmW_M1	1.0	// middle DM1 width   
VARIABLE MdmL_M1	1.0	// middle DM1 length  
VARIABLE MdmS_M1	1.0	// middle DM1 spacing   
VARIABLE Mdm2M1		1.2	// middle DM1 to real metal spacing 
VARIABLE WdmW_M1	3.0	// large DM1 width   
VARIABLE WdmL_M1	3.0	// large DM1 length  
VARIABLE WdmS_M1	2.0	// large DM1 spacing   
VARIABLE Wdm2M1		3.0	// large DM1 to real metal spacing 	
VARIABLE dmO_M1		0.2	// small DM1 offset = space*(1/3)
VARIABLE MdmO_M1	0.3	// middle DM1 offset = space*(1/3)
VARIABLE WdmO_M1	0.6	// large DM1 offset = space*(1/3)
VARIABLE minD_M1	0.3	// M1 density for insertion
VARIABLE maxD_M1	0.5	// M1 density for remove inserted dummy
VARIABLE emptyD_M1	0.001	// M1 density for blank region selection
VARIABLE dm2DM1		0.6	// DM1 to existed dummy metal spacing

VARIABLE dmW_M2		0.6	// small DM2 width   
VARIABLE dmL_M2		0.6	// small DM2 length  
VARIABLE dmS_M2		0.6	// small DM2 spacing   
VARIABLE dm2M2		1.2	// small DM2 to real metal spacing 	
VARIABLE MdmW_M2	1.0	// middle DM2 width   
VARIABLE MdmL_M2	1.0	// middle DM2 length  
VARIABLE MdmS_M2	1.0	// middle DM2 spacing   
VARIABLE Mdm2M2		1.2	// middle DM2 to real metal spacing 
VARIABLE WdmW_M2	3.0	// large DM2 width   
VARIABLE WdmL_M2	3.0	// large DM2 length  
VARIABLE WdmS_M2	2.0	// large DM2 spacing   
VARIABLE Wdm2M2		3.0	// large DM2 to real metal spacing 	
VARIABLE dmO_M2		0.2	// small DM2 offset = space*(1/3)
VARIABLE MdmO_M2	0.3	// middle DM2 offset = space*(1/3)
VARIABLE WdmO_M2	0.6	// large DM2 offset = space*(1/3)
VARIABLE minD_M2	0.3	// M2 density for insertion
VARIABLE maxD_M2	0.5	// M2 density for remove inserted dummy
VARIABLE emptyD_M2	0.001	// M2 density for blank region selection
VARIABLE dm2DM2		0.6	// DM2 to existed dummy metal spacing

#IFDEF THICK_40K_M3
#IFDEF RFSWITCH
VARIABLE dmW_M3		4.5	// small DM3 width   
VARIABLE dmL_M3		4.5	// small DM3 length  
VARIABLE dmS_M3		3.0	// small DM3 spacing   
VARIABLE dm2M3		5.0	// small DM3 to real metal spacing 	
VARIABLE MdmW_M3	4.5	// middle DM3 width   
VARIABLE MdmL_M3	4.5	// middle DM3 length  
VARIABLE MdmS_M3	3.0	// middle DM3 spacing   
VARIABLE Mdm2M3		5.0	// middle DM3 to real metal spacing 
VARIABLE WdmW_M3	4.5	// large DM3 width   
VARIABLE WdmL_M3	4.5	// large DM3 length  
VARIABLE WdmS_M3	3.0	// large DM3 spacing   
VARIABLE Wdm2M3		5.0	// large DM3 to real metal spacing 	
VARIABLE dmO_M3		1.0	// small DM3 offset = space*(1/3)
VARIABLE MdmO_M3	1.0	// middle DM3 offset = space*(1/3)
VARIABLE WdmO_M3	1.0	// large DM3 offset = space*(1/3)
VARIABLE minD_M3	0.3	// M3 density for insertion
VARIABLE maxD_M3	0.55	// M3 density for remove inserted dummy
#ELSE
VARIABLE dmW_M3		3.0	// small DM3 width   
VARIABLE dmL_M3		3.0	// small DM3 length  
VARIABLE dmS_M3		3.0	// small DM3 spacing   
VARIABLE dm2M3		5.0	// small DM3 to real metal spacing 	
VARIABLE MdmW_M3	3.0	// middle DM3 width   
VARIABLE MdmL_M3	3.0	// middle DM3 length  
VARIABLE MdmS_M3	3.0	// middle DM3 spacing   
VARIABLE Mdm2M3		5.0	// middle DM3 to real metal spacing 
VARIABLE WdmW_M3	3.0	// large DM3 width   
VARIABLE WdmL_M3	3.0	// large DM3 length  
VARIABLE WdmS_M3	3.0	// large DM3 spacing   
VARIABLE Wdm2M3		5.0	// large DM3 to real metal spacing 	
VARIABLE dmO_M3		1.0	// small DM3 offset = space*(1/3)
VARIABLE MdmO_M3	1.0	// middle DM3 offset = space*(1/3)
VARIABLE WdmO_M3	1.0	// large DM3 offset = space*(1/3)
VARIABLE minD_M3	0.3	// M3 density for insertion
VARIABLE maxD_M3	0.5	// M3 density for remove inserted dummy
#ENDIF
VARIABLE emptyD_M3	0.001	// M3 density for blank region selection
VARIABLE dm2DM3		3	// DM3 to existed dummy metal spacing
#ELSE
#IFDEF THICK_30K_M3
VARIABLE dmW_M3		3.0	// small DM3 width   
VARIABLE dmL_M3		3.0	// small DM3 length  
VARIABLE dmS_M3		3.0	// small DM3 spacing   
VARIABLE dm2M3		5.0	// small DM3 to real metal spacing 	
VARIABLE MdmW_M3	3.0	// middle DM3 width   
VARIABLE MdmL_M3	3.0	// middle DM3 length  
VARIABLE MdmS_M3	3.0	// middle DM3 spacing   
VARIABLE Mdm2M3		5.0	// middle DM3 to real metal spacing 
VARIABLE WdmW_M3	3.0	// large DM3 width   
VARIABLE WdmL_M3	3.0	// large DM3 length  
VARIABLE WdmS_M3	3.0	// large DM3 spacing   
VARIABLE Wdm2M3		5.0	// large DM3 to real metal spacing 	
VARIABLE dmO_M3		1.0	// small DM3 offset = space*(1/3)
VARIABLE MdmO_M3	1.0	// middle DM3 offset = space*(1/3)
VARIABLE WdmO_M3	1.0	// large DM3 offset = space*(1/3)
VARIABLE minD_M3	0.3	// M3 density for insertion
VARIABLE maxD_M3	0.5	// M3 density for remove inserted dummy
VARIABLE emptyD_M3	0.001	// M3 density for blank region selection
VARIABLE dm2DM3		3	// DM3 to existed dummy metal spacing
#ELSE
#IFDEF THICK_M3
VARIABLE dmW_M3		3.0	// small DM3 width   
VARIABLE dmL_M3		3.0	// small DM3 length  
VARIABLE dmS_M3		2.0	// small DM3 spacing   
VARIABLE dm2M3		5.0	// small DM3 to real metal spacing 	
VARIABLE MdmW_M3	3.0	// middle DM3 width   
VARIABLE MdmL_M3	3.0	// middle DM3 length  
VARIABLE MdmS_M3	2.0	// middle DM3 spacing   
VARIABLE Mdm2M3		5.0	// middle DM3 to real metal spacing 
VARIABLE WdmW_M3	3.0	// large DM3 width   
VARIABLE WdmL_M3	3.0	// large DM3 length  
VARIABLE WdmS_M3	2.0	// large DM3 spacing   
VARIABLE Wdm2M3		5.0	// large DM3 to real metal spacing 	
VARIABLE dmO_M3		0.6	// small DM3 offset = space*(1/3)
VARIABLE MdmO_M3	0.6	// middle DM3 offset = space*(1/3)
VARIABLE WdmO_M3	0.6	// large DM3 offset = space*(1/3)
VARIABLE minD_M3	0.3	// M3 density for insertion
VARIABLE maxD_M3	0.5	// M3 density for remove inserted dummy
VARIABLE emptyD_M3	0.001	// M3 density for blank region selection
VARIABLE dm2DM3		3	// DM3 to existed dummy metal spacing
#ELSE
VARIABLE dmW_M3		0.6	// small DM3 width   
VARIABLE dmL_M3		0.6	// small DM3 length  
VARIABLE dmS_M3		0.6	// small DM3 spacing   
VARIABLE dm2M3		1.2	// small DM3 to real metal spacing 	
VARIABLE MdmW_M3	1.0	// middle DM3 width   
VARIABLE MdmL_M3	1.0	// middle DM3 length  
VARIABLE MdmS_M3	1.0	// middle DM3 spacing   
VARIABLE Mdm2M3		1.2	// middle DM3 to real metal spacing 
VARIABLE WdmW_M3	3.0	// large DM3 width   
VARIABLE WdmL_M3	3.0	// large DM3 length  
VARIABLE WdmS_M3	2.0	// large DM3 spacing   
VARIABLE Wdm2M3		3.0	// large DM3 to real metal spacing 	
VARIABLE dmO_M3		0.2	// small DM3 offset = space*(1/3)
VARIABLE MdmO_M3	0.3	// middle DM3 offset = space*(1/3)
VARIABLE WdmO_M3	0.6	// large DM3 offset = space*(1/3)
VARIABLE minD_M3	0.3	// M3 density for insertion
VARIABLE maxD_M3	0.5	// M3 density for remove inserted dummy
VARIABLE emptyD_M3	0.001	// M3 density for blank region selection
VARIABLE dm2DM3		0.6	// DM3 to existed dummy metal spacing
#ENDIF
#ENDIF
#ENDIF

#IFDEF THICK_40K_M4
#IFDEF RFSWITCH
VARIABLE dmW_M4		4.5	// small DM4 width   
VARIABLE dmL_M4		4.5	// small DM4 length  
VARIABLE dmS_M4		3.0	// small DM4 spacing   
VARIABLE dm2M4		5.0	// small DM4 to real metal spacing 	
VARIABLE MdmW_M4	4.5	// middle DM4 width   
VARIABLE MdmL_M4	4.5	// middle DM4 length  
VARIABLE MdmS_M4	3.0	// middle DM4 spacing   
VARIABLE Mdm2M4		5.0	// middle DM4 to real metal spacing 
VARIABLE WdmW_M4	4.5	// large DM4 width   
VARIABLE WdmL_M4	4.5	// large DM4 length  
VARIABLE WdmS_M4	3.0	// large DM4 spacing   
VARIABLE Wdm2M4		5.0	// large DM4 to real metal spacing 	
VARIABLE dmO_M4		1.0	// small DM4 offset = space*(1/3)
VARIABLE MdmO_M4	1.0	// middle DM4 offset = space*(1/3)
VARIABLE WdmO_M4	1.0	// large DM4 offset = space*(1/3)
VARIABLE minD_M4	0.3	// M4 density for insertion
VARIABLE maxD_M4	0.55	// M4 density for remove inserted dummy
#ELSE
VARIABLE dmW_M4		3.0	// small DM4 width   
VARIABLE dmL_M4		3.0	// small DM4 length  
VARIABLE dmS_M4		3.0	// small DM4 spacing   
VARIABLE dm2M4		5.0	// small DM4 to real metal spacing 	
VARIABLE MdmW_M4	3.0	// middle DM4 width   
VARIABLE MdmL_M4	3.0	// middle DM4 length  
VARIABLE MdmS_M4	3.0	// middle DM4 spacing   
VARIABLE Mdm2M4		5.0	// middle DM4 to real metal spacing 
VARIABLE WdmW_M4	3.0	// large DM4 width   
VARIABLE WdmL_M4	3.0	// large DM4 length  
VARIABLE WdmS_M4	3.0	// large DM4 spacing   
VARIABLE Wdm2M4		5.0	// large DM4 to real metal spacing 	
VARIABLE dmO_M4		1.0	// small DM4 offset = space*(1/3)
VARIABLE MdmO_M4	1.0	// middle DM4 offset = space*(1/3)
VARIABLE WdmO_M4	1.0	// large DM4 offset = space*(1/3)
VARIABLE minD_M4	0.3	// M4 density for insertion
VARIABLE maxD_M4	0.5	// M4 density for remove inserted dummy
#ENDIF
VARIABLE emptyD_M4	0.001	// M4 density for blank region selection
VARIABLE dm2DM4		3	// DM4 to existed dummy metal spacing
#ELSE
#IFDEF THICK_30K_M4
VARIABLE dmW_M4		3.0	// small DM4 width   
VARIABLE dmL_M4		3.0	// small DM4 length  
VARIABLE dmS_M4		3.0	// small DM4 spacing   
VARIABLE dm2M4		5.0	// small DM4 to real metal spacing 	
VARIABLE MdmW_M4	3.0	// middle DM4 width   
VARIABLE MdmL_M4	3.0	// middle DM4 length  
VARIABLE MdmS_M4	3.0	// middle DM4 spacing   
VARIABLE Mdm2M4		5.0	// middle DM4 to real metal spacing 
VARIABLE WdmW_M4	3.0	// large DM4 width   
VARIABLE WdmL_M4	3.0	// large DM4 length  
VARIABLE WdmS_M4	3.0	// large DM4 spacing   
VARIABLE Wdm2M4		5.0	// large DM4 to real metal spacing 	
VARIABLE dmO_M4		1.0	// small DM4 offset = space*(1/3)
VARIABLE MdmO_M4	1.0	// middle DM4 offset = space*(1/3)
VARIABLE WdmO_M4	1.0	// large DM4 offset = space*(1/3)
VARIABLE minD_M4	0.3	// M4 density for insertion
VARIABLE maxD_M4	0.5	// M4 density for remove inserted dummy
VARIABLE emptyD_M4	0.001	// M4 density for blank region selection
VARIABLE dm2DM4		3	// DM4 to existed dummy metal spacing
#ELSE
#IFDEF THICK_M4
VARIABLE dmW_M4		3.0	// small DM4 width   
VARIABLE dmL_M4		3.0	// small DM4 length  
VARIABLE dmS_M4		2.0	// small DM4 spacing   
VARIABLE dm2M4		5.0	// small DM4 to real metal spacing 	
VARIABLE MdmW_M4	3.0	// middle DM4 width   
VARIABLE MdmL_M4	3.0	// middle DM4 length  
VARIABLE MdmS_M4	2.0	// middle DM4 spacing   
VARIABLE Mdm2M4		5.0	// middle DM4 to real metal spacing 
VARIABLE WdmW_M4	3.0	// large DM4 width   
VARIABLE WdmL_M4	3.0	// large DM4 length  
VARIABLE WdmS_M4	2.0	// large DM4 spacing   
VARIABLE Wdm2M4		5.0	// large DM4 to real metal spacing 	
VARIABLE dmO_M4		0.6	// small DM4 offset = space*(1/3)
VARIABLE MdmO_M4	0.6	// middle DM4 offset = space*(1/3)
VARIABLE WdmO_M4	0.6	// large DM4 offset = space*(1/3)
VARIABLE minD_M4	0.3	// M4 density for insertion
VARIABLE maxD_M4	0.5	// M4 density for remove inserted dummy
VARIABLE emptyD_M4	0.001	// M4 density for blank region selection
VARIABLE dm2DM4		3	// DM4 to existed dummy metal spacing
#ELSE
VARIABLE dmW_M4		0.6	// small DM4 width   
VARIABLE dmL_M4		0.6	// small DM4 length  
VARIABLE dmS_M4		0.6	// small DM4 spacing   
VARIABLE dm2M4		1.2	// small DM4 to real metal spacing 	
VARIABLE MdmW_M4	1.0	// middle DM4 width   
VARIABLE MdmL_M4	1.0	// middle DM4 length  
VARIABLE MdmS_M4	1.0	// middle DM4 spacing   
VARIABLE Mdm2M4		1.2	// middle DM4 to real metal spacing 
VARIABLE WdmW_M4	3.0	// large DM4 width   
VARIABLE WdmL_M4	3.0	// large DM4 length  
VARIABLE WdmS_M4	2.0	// large DM4 spacing   
VARIABLE Wdm2M4		3.0	// large DM4 to real metal spacing 	
VARIABLE dmO_M4		0.2	// small DM4 offset = space*(1/3)
VARIABLE MdmO_M4	0.3	// middle DM4 offset = space*(1/3)
VARIABLE WdmO_M4	0.6	// large DM4 offset = space*(1/3)
VARIABLE minD_M4	0.3	// M4 density for insertion
VARIABLE maxD_M4	0.5	// M4 density for remove inserted dummy
VARIABLE emptyD_M4	0.001	// M4 density for blank region selection
VARIABLE dm2DM4		0.6	// DM4 to existed dummy metal spacing
#ENDIF
#ENDIF
#ENDIF

#IFDEF THICK_40K_M5
#IFDEF RFSWITCH
VARIABLE dmW_M5		4.5	// small DM5 width   
VARIABLE dmL_M5		4.5	// small DM5 length  
VARIABLE dmS_M5		3.0	// small DM5 spacing   
VARIABLE dm2M5		5.0	// small DM5 to real metal spacing 	
VARIABLE MdmW_M5	4.5	// middle DM5 width   
VARIABLE MdmL_M5	4.5	// middle DM5 length  
VARIABLE MdmS_M5	3.0	// middle DM5 spacing   
VARIABLE Mdm2M5		5.0	// middle DM5 to real metal spacing 
VARIABLE WdmW_M5	4.5	// large DM5 width   
VARIABLE WdmL_M5	4.5	// large DM5 length  
VARIABLE WdmS_M5	3.0	// large DM5 spacing   
VARIABLE Wdm2M5		5.0	// large DM5 to real metal spacing 	
VARIABLE dmO_M5		1.0	// small DM5 offset = space*(1/3)
VARIABLE MdmO_M5	1.0	// middle DM5 offset = space*(1/3)
VARIABLE WdmO_M5	1.0	// large DM5 offset = space*(1/3)
VARIABLE minD_M5	0.3	// M5 density for insertion
VARIABLE maxD_M5	0.55	// M5 density for remove inserted dummy
#ELSE
VARIABLE dmW_M5		3.0	// small DM5 width   
VARIABLE dmL_M5		3.0	// small DM5 length  
VARIABLE dmS_M5		3.0	// small DM5 spacing   
VARIABLE dm2M5		5.0	// small DM5 to real metal spacing 	
VARIABLE MdmW_M5	3.0	// middle DM5 width   
VARIABLE MdmL_M5	3.0	// middle DM5 length  
VARIABLE MdmS_M5	3.0	// middle DM5 spacing   
VARIABLE Mdm2M5		5.0	// middle DM5 to real metal spacing 
VARIABLE WdmW_M5	3.0	// large DM5 width   
VARIABLE WdmL_M5	3.0	// large DM5 length  
VARIABLE WdmS_M5	3.0	// large DM5 spacing   
VARIABLE Wdm2M5		5.0	// large DM5 to real metal spacing 	
VARIABLE dmO_M5		1.0	// small DM5 offset = space*(1/3)
VARIABLE MdmO_M5	1.0	// middle DM5 offset = space*(1/3)
VARIABLE WdmO_M5	1.0	// large DM5 offset = space*(1/3)
VARIABLE minD_M5	0.3	// M5 density for insertion
VARIABLE maxD_M5	0.5	// M5 density for remove inserted dummy
#ENDIF
VARIABLE emptyD_M5	0.001	// M5 density for blank region selection
VARIABLE dm2DM5		3	// DM5 to existed dummy metal spacing
#ELSE
#IFDEF THICK_30K_M5
VARIABLE dmW_M5		3.0	// small DM5 width   
VARIABLE dmL_M5		3.0	// small DM5 length  
VARIABLE dmS_M5		3.0	// small DM5 spacing   
VARIABLE dm2M5		5.0	// small DM5 to real metal spacing 	
VARIABLE MdmW_M5	3.0	// middle DM5 width   
VARIABLE MdmL_M5	3.0	// middle DM5 length  
VARIABLE MdmS_M5	3.0	// middle DM5 spacing   
VARIABLE Mdm2M5		5.0	// middle DM5 to real metal spacing 
VARIABLE WdmW_M5	3.0	// large DM5 width   
VARIABLE WdmL_M5	3.0	// large DM5 length  
VARIABLE WdmS_M5	3.0	// large DM5 spacing   
VARIABLE Wdm2M5		5.0	// large DM5 to real metal spacing 	
VARIABLE dmO_M5		1.0	// small DM5 offset = space*(1/3)
VARIABLE MdmO_M5	1.0	// middle DM5 offset = space*(1/3)
VARIABLE WdmO_M5	1.0	// large DM5 offset = space*(1/3)
VARIABLE minD_M5	0.3	// M5 density for insertion
VARIABLE maxD_M5	0.5	// M5 density for remove inserted dummy
VARIABLE emptyD_M5	0.001	// M5 density for blank region selection
VARIABLE dm2DM5		3	// DM5 to existed dummy metal spacing
#ELSE
#IFDEF THICK_M5
VARIABLE dmW_M5		3.0	// small DM5 width   
VARIABLE dmL_M5		3.0	// small DM5 length  
VARIABLE dmS_M5		2.0	// small DM5 spacing   
VARIABLE dm2M5		5.0	// small DM5 to real metal spacing 	
VARIABLE MdmW_M5	3.0	// middle DM5 width   
VARIABLE MdmL_M5	3.0	// middle DM5 length  
VARIABLE MdmS_M5	2.0	// middle DM5 spacing   
VARIABLE Mdm2M5		5.0	// middle DM5 to real metal spacing 
VARIABLE WdmW_M5	3.0	// large DM5 width   
VARIABLE WdmL_M5	3.0	// large DM5 length  
VARIABLE WdmS_M5	2.0	// large DM5 spacing   
VARIABLE Wdm2M5		5.0	// large DM5 to real metal spacing 	
VARIABLE dmO_M5		0.6	// small DM5 offset = space*(1/3)
VARIABLE MdmO_M5	0.6	// middle DM5 offset = space*(1/3)
VARIABLE WdmO_M5	0.6	// large DM5 offset = space*(1/3)
VARIABLE minD_M5	0.3	// M5 density for insertion
VARIABLE maxD_M5	0.5	// M5 density for remove inserted dummy
VARIABLE emptyD_M5	0.001	// M5 density for blank region selection
VARIABLE dm2DM5		3	// DM5 to existed dummy metal spacing
#ELSE
VARIABLE dmW_M5		0.6	// small DM5 width   
VARIABLE dmL_M5		0.6	// small DM5 length  
VARIABLE dmS_M5		0.6	// small DM5 spacing   
VARIABLE dm2M5		1.2	// small DM5 to real metal spacing 	
VARIABLE MdmW_M5	1.0	// middle DM5 width   
VARIABLE MdmL_M5	1.0	// middle DM5 length  
VARIABLE MdmS_M5	1.0	// middle DM5 spacing   
VARIABLE Mdm2M5		1.2	// middle DM5 to real metal spacing 
VARIABLE WdmW_M5	3.0	// large DM5 width   
VARIABLE WdmL_M5	3.0	// large DM5 length  
VARIABLE WdmS_M5	2.0	// large DM5 spacing   
VARIABLE Wdm2M5		3.0	// large DM5 to real metal spacing 	
VARIABLE dmO_M5		0.2	// small DM5 offset = space*(1/3)
VARIABLE MdmO_M5	0.3	// middle DM5 offset = space*(1/3)
VARIABLE WdmO_M5	0.6	// large DM5 offset = space*(1/3)
VARIABLE minD_M5	0.3	// M5 density for insertion
VARIABLE maxD_M5	0.5	// M5 density for remove inserted dummy
VARIABLE emptyD_M5	0.001	// M5 density for blank region selection
VARIABLE dm2DM5		0.6	// DM5 to existed dummy metal spacing
#ENDIF
#ENDIF
#ENDIF

#IFDEF THICK_40K_M6
#IFDEF RFSWITCH
VARIABLE dmW_M6		4.5	// small DM6 width   
VARIABLE dmL_M6		4.5	// small DM6 length  
VARIABLE dmS_M6		3.0	// small DM6 spacing   
VARIABLE dm2M6		5.0	// small DM6 to real metal spacing 	
VARIABLE MdmW_M6	4.5	// middle DM6 width   
VARIABLE MdmL_M6	4.5	// middle DM6 length  
VARIABLE MdmS_M6	3.0	// middle DM6 spacing   
VARIABLE Mdm2M6		5.0	// middle DM6 to real metal spacing 
VARIABLE WdmW_M6	4.5	// large DM6 width   
VARIABLE WdmL_M6	4.5	// large DM6 length  
VARIABLE WdmS_M6	3.0	// large DM6 spacing   
VARIABLE Wdm2M6		5.0	// large DM6 to real metal spacing 	
VARIABLE dmO_M6		1.0	// small DM6 offset = space*(1/3)
VARIABLE MdmO_M6	1.0	// middle DM6 offset = space*(1/3)
VARIABLE WdmO_M6	1.0	// large DM6 offset = space*(1/3)
VARIABLE minD_M6	0.3	// M6 density for insertion
VARIABLE maxD_M6	0.55	// M6 density for remove inserted dummy
#ELSE
VARIABLE dmW_M6		3.0	// small DM6 width   
VARIABLE dmL_M6		3.0	// small DM6 length  
VARIABLE dmS_M6		3.0	// small DM6 spacing   
VARIABLE dm2M6		5.0	// small DM6 to real metal spacing 	
VARIABLE MdmW_M6	3.0	// middle DM6 width   
VARIABLE MdmL_M6	3.0	// middle DM6 length  
VARIABLE MdmS_M6	3.0	// middle DM6 spacing   
VARIABLE Mdm2M6		5.0	// middle DM6 to real metal spacing 
VARIABLE WdmW_M6	3.0	// large DM6 width   
VARIABLE WdmL_M6	3.0	// large DM6 length  
VARIABLE WdmS_M6	3.0	// large DM6 spacing   
VARIABLE Wdm2M6		5.0	// large DM6 to real metal spacing 	
VARIABLE dmO_M6		1.0	// small DM6 offset = space*(1/3)
VARIABLE MdmO_M6	1.0	// middle DM6 offset = space*(1/3)
VARIABLE WdmO_M6	1.0	// large DM6 offset = space*(1/3)
VARIABLE minD_M6	0.3	// M6 density for insertion
VARIABLE maxD_M6	0.5	// M6 density for remove inserted dummy
#ENDIF
VARIABLE emptyD_M6	0.001	// M6 density for blank region selection
VARIABLE dm2DM6		3	// DM6 to existed dummy metal spacing
#ELSE
#IFDEF THICK_30K_M6
VARIABLE dmW_M6		3.0	// small DM6 width   
VARIABLE dmL_M6		3.0	// small DM6 length  
VARIABLE dmS_M6		3.0	// small DM6 spacing   
VARIABLE dm2M6		5.0	// small DM6 to real metal spacing 	
VARIABLE MdmW_M6	3.0	// middle DM6 width   
VARIABLE MdmL_M6	3.0	// middle DM6 length  
VARIABLE MdmS_M6	3.0	// middle DM6 spacing   
VARIABLE Mdm2M6		5.0	// middle DM6 to real metal spacing 
VARIABLE WdmW_M6	3.0	// large DM6 width   
VARIABLE WdmL_M6	3.0	// large DM6 length  
VARIABLE WdmS_M6	3.0	// large DM6 spacing   
VARIABLE Wdm2M6		5.0	// large DM6 to real metal spacing 	
VARIABLE dmO_M6		1.0	// small DM6 offset = space*(1/3)
VARIABLE MdmO_M6	1.0	// middle DM6 offset = space*(1/3)
VARIABLE WdmO_M6	1.0	// large DM6 offset = space*(1/3)
VARIABLE minD_M6	0.3	// M6 density for insertion
VARIABLE maxD_M6	0.5	// M6 density for remove inserted dummy
VARIABLE emptyD_M6	0.001	// M6 density for blank region selection
VARIABLE dm2DM6		3	// DM6 to existed dummy metal spacing
#ELSE
#IFDEF THICK_M6
VARIABLE dmW_M6		3.0	// small DM6 width   
VARIABLE dmL_M6		3.0	// small DM6 length  
VARIABLE dmS_M6		2.0	// small DM6 spacing   
VARIABLE dm2M6		5.0	// small DM6 to real metal spacing 	
VARIABLE MdmW_M6	3.0	// middle DM6 width   
VARIABLE MdmL_M6	3.0	// middle DM6 length  
VARIABLE MdmS_M6	2.0	// middle DM6 spacing   
VARIABLE Mdm2M6		5.0	// middle DM6 to real metal spacing 
VARIABLE WdmW_M6	3.0	// large DM6 width   
VARIABLE WdmL_M6	3.0	// large DM6 length  
VARIABLE WdmS_M6	2.0	// large DM6 spacing   
VARIABLE Wdm2M6		5.0	// large DM6 to real metal spacing 	
VARIABLE dmO_M6		0.6	// small DM6 offset = space*(1/3)
VARIABLE MdmO_M6	0.6	// middle DM6 offset = space*(1/3)
VARIABLE WdmO_M6	0.6	// large DM6 offset = space*(1/3)
VARIABLE minD_M6	0.3	// M6 density for insertion
VARIABLE maxD_M6	0.5	// M6 density for remove inserted dummy
VARIABLE emptyD_M6	0.001	// M6 density for blank region selection
VARIABLE dm2DM6		3	// DM6 to existed dummy metal spacing
#ELSE
VARIABLE dmW_M6		0.6	// small DM6 width   
VARIABLE dmL_M6		0.6	// small DM6 length  
VARIABLE dmS_M6		0.6	// small DM6 spacing   
VARIABLE dm2M6		1.2	// small DM6 to real metal spacing 	
VARIABLE MdmW_M6	1.0	// middle DM6 width   
VARIABLE MdmL_M6	1.0	// middle DM6 length  
VARIABLE MdmS_M6	1.0	// middle DM6 spacing   
VARIABLE Mdm2M6		1.2	// middle DM6 to real metal spacing 
VARIABLE WdmW_M6	3.0	// large DM6 width   
VARIABLE WdmL_M6	3.0	// large DM6 length  
VARIABLE WdmS_M6	2.0	// large DM6 spacing   
VARIABLE Wdm2M6		3.0	// large DM6 to real metal spacing 	
VARIABLE dmO_M6		0.2	// small DM6 offset = space*(1/3)
VARIABLE MdmO_M6	0.3	// middle DM6 offset = space*(1/3)
VARIABLE WdmO_M6	0.6	// large DM6 offset = space*(1/3)
VARIABLE minD_M6	0.3	// M6 density for insertion
VARIABLE maxD_M6	0.5	// M6 density for remove inserted dummy
VARIABLE emptyD_M6	0.001	// M6 density for blank region selection
VARIABLE dm2DM6		0.6	// DM6 to existed dummy metal spacing
#ENDIF
#ENDIF
#ENDIF

VARIABLE dmW_MD		3.0	// small DMD width   
VARIABLE dmL_MD		3.0	// small DMD length  
VARIABLE dmS_MD		2.0	// small DMD spacing   
VARIABLE dm2MD		5.0	// small DMD to real metal spacing 	
VARIABLE MdmW_MD	3.0	// middle DMD width   
VARIABLE MdmL_MD	3.0	// middle DMD length  
VARIABLE MdmS_MD	2.0	// middle DMD spacing   
VARIABLE Mdm2MD		5.0	// middle DMD to real metal spacing 
VARIABLE WdmW_MD	3.0	// large DMD width   
VARIABLE WdmL_MD	3.0	// large DMD length  
VARIABLE WdmS_MD	2.0	// large DMD spacing   
VARIABLE Wdm2MD		5.0	// large DMD to real metal spacing 	
VARIABLE dmO_MD		0.6	// small DMD offset = space*(1/3)
VARIABLE MdmO_MD	0.6	// middle DMD offset = space*(1/3)
VARIABLE WdmO_MD	0.6	// large DMD offset = space*(1/3)
VARIABLE minD_MD	0.3	// MD density for insertion
VARIABLE maxD_MD	0.5	// MD density for remove inserted dummy
VARIABLE emptyD_MD	0.001	// MD density for blank region selection
VARIABLE dm2DMD		3	// DMD to existed dummy metal spacing

// offset for fill region of even level dummy metal
VARIABLE Mdm_offset	0.5
VARIABLE Wdm_offset	1.5

//******* Chip boundary pre-definition *********************************

#IFNDEF ChipWindowUsed
DummyRule.ChipWindow { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  ChipWindow NOT bulk
}
DummyRule.NWELi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  NWELi NOT bulk
}
DummyRule.DIFFi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  DIFFi NOT bulk
}
DummyRule.DOD { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  DOD NOT bulk
}
DummyRule.ODBLK { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  ODBLK NOT bulk
}
DummyRule.PDIFFi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  PDIFFi NOT bulk
}
DummyRule.NDIFFi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  NDIFFi NOT bulk
}
DummyRule.OD2i { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  OD2i NOT bulk
}
DummyRule.POLYi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  POLYi NOT bulk
}
DummyRule.DPO { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  DPO NOT bulk
}
DummyRule.POBLK { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  POBLK NOT bulk
}
DummyRule.PPi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  PPi NOT bulk
}
DummyRule.NPi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  NPi NOT bulk
}
DummyRule.FLASH { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  FLASH NOT bulk
}
DummyRule.HVNWi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  HVNWi NOT bulk
}
DummyRule.HVOXi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  HVOXi NOT bulk
}
DummyRule.HVDMYi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  HVDMYi NOT bulk
}
DummyRule.NLVTi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  NLVTi NOT bulk
}
DummyRule.HV60DMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  HV60DMY NOT bulk
}
DummyRule.CTMDMYUD { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  CTMDMYUD NOT bulk
}
DummyRule.RFDUMMYUD { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  RFDUMMYUD NOT bulk
}
DummyRule.DTi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  DTi NOT bulk
}
DummyRule.DTBLK { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  DTBLK NOT bulk
}
DummyRule.NLD { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  NLD NOT bulk
}
DummyRule.SOILDi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  SOILDi NOT bulk
}
DummyRule.SOIBTi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  SOIBTi NOT bulk
}
DummyRule.SOIDRNi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  SOIDRNi NOT bulk
}
DummyRule.SOILGi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  SOILGi NOT bulk
}
DummyRule.SOI1Gi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  SOI1Gi NOT bulk
}
DummyRule.CB2i { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  CB2i NOT bulk
}
DummyRule.RVi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  RVi NOT bulk
}
DummyRule.APi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  APi NOT bulk
}
DummyRule.PM1i { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  PM1i NOT bulk
}
DummyRule.PM2i { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  PM2i NOT bulk
}
DummyRule.CU_PPI_10UM { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  CU_PPI_10UM NOT bulk
}
DummyRule.CU_PPI_4UM { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  CU_PPI_4UM NOT bulk
}
DummyRule.BJTDUMMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  BJTDUMMY NOT bulk
}
DummyRule.DIODUMMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  DIODUMMY NOT bulk
}
DummyRule.RPDUMMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  RPDUMMY NOT bulk
}
DummyRule.COi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  COi NOT bulk
}
DummyRule.M1i { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  M1i NOT bulk
}
DummyRule.VIA1i { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  VIA1i NOT bulk
}
DummyRule.M2i { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  M2i NOT bulk
}
DummyRule.VIA2i { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  VIA2i NOT bulk
}
DummyRule.M3i { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  M3i NOT bulk
}
DummyRule.VIA3i { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  VIA3i NOT bulk
}
DummyRule.M4i { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  M4i NOT bulk
}
DummyRule.VIA4i { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  VIA4i NOT bulk
}
DummyRule.M5i { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  M5i NOT bulk
}
DummyRule.VIA5i { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  VIA5i NOT bulk
}
DummyRule.M6i { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  M6i NOT bulk
}
DummyRule.VIADi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  VIADi NOT bulk
}
DummyRule.MDi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  MDi NOT bulk
}
DummyRule.CBi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  CBi NOT bulk
}
DummyRule.CBDi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  CBDi NOT bulk
}
DummyRule.UBMi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  UBMi NOT bulk
}
DummyRule.PPIi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  PPIi NOT bulk
}
DummyRule.RPOi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  RPOi NOT bulk
}
DummyRule.NTNi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  NTNi NOT bulk
}
DummyRule.PLMIDEi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  PLMIDEi NOT bulk
}
DummyRule.DNWi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  DNWi NOT bulk
}
DummyRule.VTMPi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  VTMPi NOT bulk
}
DummyRule.VTMNi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  VTMNi NOT bulk
}
DummyRule.PV_P { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  PV_P NOT bulk
}
DummyRule.PV_N { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  PV_N NOT bulk
}
DummyRule.HRIi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  HRIi NOT bulk
}
DummyRule.M1DMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  M1DMY NOT bulk
}
DummyRule.M2DMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  M2DMY NOT bulk
}
DummyRule.M3DMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  M3DMY NOT bulk
}
DummyRule.M4DMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  M4DMY NOT bulk
}
DummyRule.M5DMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  M5DMY NOT bulk
}
DummyRule.M6DMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  M6DMY NOT bulk
}
DummyRule.MDDMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  MDDMY NOT bulk
}
DummyRule.M1SLOTi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  M1SLOTi NOT bulk
}
DummyRule.M2SLOTi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  M2SLOTi NOT bulk
}
DummyRule.M3SLOTi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  M3SLOTi NOT bulk
}
DummyRule.M4SLOTi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  M4SLOTi NOT bulk
}
DummyRule.M5SLOTi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  M5SLOTi NOT bulk
}
DummyRule.M6SLOTi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  M6SLOTi NOT bulk
}
DummyRule.MDSLOTi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  MDSLOTi NOT bulk
}
DummyRule.CTM1i { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  CTM1i NOT bulk
}
DummyRule.CTM2i { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  CTM2i NOT bulk
}
DummyRule.CTM3i { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  CTM3i NOT bulk
}
DummyRule.CTM4i { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  CTM4i NOT bulk
}
DummyRule.CTM5i { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  CTM5i NOT bulk
}
DummyRule.HOTWL { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  HOTWL NOT bulk
}
DummyRule.EXCLi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  EXCLi NOT bulk
}
DummyRule.DRCDMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  DRCDMY NOT bulk
}
DummyRule.RWDMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  RWDMY NOT bulk
}
DummyRule.DPDMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  DPDMY NOT bulk
}
DummyRule.PLDMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  PLDMY NOT bulk
}
DummyRule.SDI { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  SDI NOT bulk
}
DummyRule.ESD1DMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  ESD1DMY NOT bulk
}
DummyRule.ESD2DMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  ESD2DMY NOT bulk
}
DummyRule.ESD3DMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  ESD3DMY NOT bulk
}
DummyRule.CTMDMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  CTMDMY NOT bulk
}
DummyRule.RLPPDMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  RLPPDMY NOT bulk
}
DummyRule.DMN2V { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  DMN2V NOT bulk
}
DummyRule.DMP2V { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  DMP2V NOT bulk
}
DummyRule.VARDMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  VARDMY NOT bulk
}
DummyRule.PMDMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  PMDMY NOT bulk
}
DummyRule.FWi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  FWi NOT bulk
}
DummyRule.LMARK { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  LMARK NOT bulk
}
DummyRule.LWI { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  LWI NOT bulk
}
DummyRule.WBDMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  WBDMY NOT bulk
}
DummyRule.ESDi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  ESDi NOT bulk
}
DummyRule.ESDIMPi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  ESDIMPi NOT bulk
}
DummyRule.INDDMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  INDDMY NOT bulk
}
DummyRule.SEALRING { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  SEALRING NOT bulk
}
DummyRule.LOGO { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  LOGO NOT bulk
}
DummyRule.LUPWDMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  LUPWDMY NOT bulk
}
DummyRule.VDDDMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  VDDDMY NOT bulk
}
DummyRule.VSSDMY { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  VSSDMY NOT bulk
}
DummyRule.TSVi { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  TSVi NOT bulk
}
DummyRule.DM1EXCL { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  DM1EXCL NOT bulk
}
DummyRule.DM2EXCL { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  DM2EXCL NOT bulk
}
DummyRule.DM3EXCL { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  DM3EXCL NOT bulk
}
DummyRule.DM4EXCL { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  DM4EXCL NOT bulk
}
DummyRule.DM5EXCL { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  DM5EXCL NOT bulk
}
DummyRule.DM6EXCL { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  DM6EXCL NOT bulk
}
DummyRule.DMDEXCL { @ An empty output rule to force Calibre use all assigned layer to form the correct boundary.
  DMDEXCL NOT bulk
}
#ENDIF

// *********************************************
// begin pre-generation process : find open area
// *********************************************

#IFDEF ChipWindowUsed
  POLYGON xLB yLB xRT yRT ChipWindow
  bulk_pre = PUSH ChipWindow
#ELSE
  bulk_ext = EXTENT
  bulk_pre = PUSH bulk_ext
#ENDIF  

#IFDEF WithSealring
  bulk = SIZE bulk_pre BY -(SRwidth + grid)
#ELSE
  bulk = COPY bulk_pre
#ENDIF  

#IFDEF dmOnCorner
  CHIP = SIZE bulk BY -(dm2Chip + grid)
#ELSE
// for seal-ring and chip corner excluding regions, no dummy on chip corner.
  #IFDEF BigDieCorner
  // big die shape  
	#IFDEF RFSWITCH
      #IFDEF SealringNonCSR
      // "0" chip corner excluding regions for dummy fill
        EMPTY_AREA = INT bulk < grid ABUT == 90 REGION INTERSECTING ONLY
      #ELSE
	    EMPTY_AREA = INT bulk < 74 ABUT == 90 REGION INTERSECTING ONLY
      #ENDIF
	#ELSE 
	  EMPTY_AREA = INT bulk < 350 ABUT == 90 REGION INTERSECTING ONLY
	#ENDIF
  #ELSE
  // small die shape    
	#IFDEF RFSWITCH
      #IFDEF SealringNonCSR
      // "0" chip corner excluding regions for dummy fill
        EMPTY_AREA = INT bulk < grid ABUT == 90 REGION INTERSECTING ONLY
      #ELSE
	    EMPTY_AREA = INT bulk < 74 ABUT == 90 REGION INTERSECTING ONLY
      #ENDIF
	#ELSE 
	  EMPTY_AREA = INT bulk < 125 ABUT == 90 REGION INTERSECTING ONLY
	#ENDIF
  #ENDIF
  CHIP = SIZE (bulk NOT EMPTY_AREA) BY -(dm2Chip + grid)
#ENDIF
  
//******* Blockage layers pre-defined **********************************

FWx = SIZE FWi BY (dm2FW+grid)
HV_ALL =((( HVOXi OR HVDMYi ) OR HV60DMY ) OR NLVTi ) OR HVNWi    

HVx = SIZE HV_ALL BY (dm2HV + grid)
TSVx = SIZE TSVi BY (dm2TSV + grid)
FLASHx = SIZE FLASH BY (dm2FLASH + grid)	// blocking em-flash area    
BJTDUMMYx = SIZE BJTDUMMY BY (dm2BJTDUMMY + grid)	// blocking BJT area    

LOGOx = SIZE LOGO BY (dm2LOGO + grid)		// blocking LOGO area    
LMARKx = SIZE LMARK BY (dm2LMARK+grid)
INDDMYx = SIZE INDDMY BY (dm2INDDMY+grid)
#IFDEF CTM_OVER_M2
  CTMi = COPY CTM2i
  #ELSE
  #IFDEF CTM_OVER_M3
    CTMi = COPY CTM3i
    #ELSE
    #IFDEF CTM_OVER_M4
      CTMi = COPY CTM4i
      #ELSE
      #IFDEF CTM_OVER_M5
        CTMi = COPY CTM5i
      #ELSE
        CTMi = CHIP NOT BULK  //empty layer
      #ENDIF
    #ENDIF
  #ENDIF
#ENDIF
CBM = SIZE CTMi BY 2 //define CBM region
CBMx = SIZE CBM BY (dm2CBM + grid)
#IFDEF RFSWITCH
NFILL = ((((INDDMYx OR FWx) OR LMARKx) OR HVx) OR TSVx) OR LOGOx
#ELSE
NFILL = ((((((INDDMYx OR FWx) OR LMARKx) OR HVx) OR TSVx) OR LOGOx ) OR FLASHx ) OR BJTDUMMYx
#ENDIF


//*******************************************
// begin generation process : filling pattern
//*******************************************

#ENCRYPT
#IFDEF FILL_M1

  minOPENM1 = DENSITY M1xd < minD_M1
		WINDOW WindowSize STEP WindowStep 
		INSIDE OF LAYER bulk
		BACKUP // PRINT M1Min.den
  emptyOPENM1 = DENSITY M1xd < emptyD_M1
		WINDOW emptyWindowSize STEP emptyWindowStep 
		INSIDE OF LAYER bulk
		BACKUP // PRINT M1Empty.den

  M1InnerHole = HOLES M1x INNER
  M1BigHole = SIZE M1InnerHole BY - excludeHoleSize/2
  M1ExcHole = (M1InnerHole OUTSIDE M1BigHole) NOT M1x

  BLOCKM1 = SIZE DM1EXCL BY (dm2DMEXCL + grid)	// DM1 to DM1EXCL	
	
  FRAMEAM1 = SIZE M1x BY (dm2M1 + grid)		// DM1 to real metal
  FRAMECM1= SIZE M1DMY BY (dm2DM1 + grid)		// DM1 to dummy metal
  FRAMEM1Pre = (FRAMEAM1 OR FRAMECM1) OR M1ExcHole	// excluded holes
    FRAMEM1 = (FRAMEM1Pre OR BLOCKM1) OR NFILL


  OPENM1 = PUSH ((minOPENM1 OR emptyOPENM1) AND CHIP)
  FILLM1 = OPENM1 NOT FRAMEM1
  FILLWM1pre = SIZE FILLM1 BY - (Wdm2M1 + grid)

// Large dummy pattern insertion
//================================
  FILLWM1 = (SIZE FILLWM1pre BY (WdmW_M1 - grid) UNDEROVER TRUNCATE WdmW_M1) AND FILLWM1pre 
  M1FW = RECTANGLES WdmW_M1 WdmL_M1 WdmS_M1 INSIDE OF LAYER FILLWM1
  M1FW_EXP = SIZE M1FW BY (WdmS_M1 / 2 + grid) OVERUNDER
  FILLMM1pre = FILLM1 NOT (SIZE M1FW_EXP BY (MdmS_M1 + grid))

// Middle dummy pattern insertion
//=================================
  FILLMM1 = (SIZE FILLMM1pre BY (MdmW_M1/2 - grid) UNDEROVER TRUNCATE MdmW_M1) AND FILLMM1pre 
  M1F1 = RECTANGLES MdmW_M1 MdmL_M1 MdmS_M1 INSIDE OF LAYER FILLMM1
  M1R1pre = FILLMM1pre NOT (SIZE M1F1 BY (dmS_M1 + grid))

// 1st small dummy pattern insertion
//====================================
  M1R1 = (SIZE M1R1pre BY (dmW_M1/2 - grid) UNDEROVER TRUNCATE dmW_M1) AND M1R1pre
  M1F2 = RECTANGLES dmW_M1 dmL_M1 dmS_M1 INSIDE OF LAYER M1R1
  M1R2pre = M1R1 NOT (SIZE M1F2 BY (dmS_M1 + grid))
    
// 2nd small dummy pattern insertion
//====================================
  M1R2 = (SIZE M1R2pre BY (dmW_M1/2 - grid) UNDEROVER TRUNCATE dmW_M1) AND M1R2pre
  M1F3 = RECTANGLES dmW_M1 dmL_M1 dmS_M1 INSIDE OF LAYER M1R2
  M1R3pre = M1R2 NOT (SIZE M1F3 BY (dmS_M1 + grid))
    
// 3rd small dummy pattern insertion
//====================================
  M1R3 = (SIZE M1R3pre BY (dmW_M1/2 - grid) UNDEROVER TRUNCATE dmW_M1) AND M1R3pre
  M1F4 = RECTANGLES dmW_M1 dmL_M1 dmS_M1 OFFSET dmO_M1 INSIDE OF LAYER M1R3 MAINTAIN SPACING

  M1F = (((M1F1 OR M1F2) OR M1F3) OR M1F4) OR M1FW
  FM1 = M1F NOT INTERACT (EXT M1F < dmS_M1 ABUT SINGULAR REGION)
	
  maxOPENM1 = DENSITY M1xd FM1 > maxD_M1 
		WINDOW WindowSize STEP WindowStep 
		INSIDE OF LAYER bulk
		BACKUP // PRINT M1Max.den
		
  DM1_FILL { @ Fill Dummy M1 pattern
    FM1 OUTSIDE maxOPENM1
  }	

#ENDIF
#IFDEF FILL_M2

  minOPENM2 = DENSITY M2xd < minD_M2
		WINDOW WindowSize STEP WindowStep 
		INSIDE OF LAYER bulk
		BACKUP // PRINT M2Min.den
  emptyOPENM2 = DENSITY M2xd < emptyD_M2
		WINDOW emptyWindowSize STEP emptyWindowStep 
		INSIDE OF LAYER bulk
		BACKUP // PRINT M2Empty.den

  M2InnerHole = HOLES M2x INNER
  M2BigHole = SIZE M2InnerHole BY - excludeHoleSize/2
  M2ExcHole = (M2InnerHole OUTSIDE M2BigHole) NOT M2x

  BLOCKM2 = SIZE DM2EXCL BY (dm2DMEXCL + grid)	// DM2 to DM2EXCL	
	
  FRAMEAM2 = SIZE M2x BY (dm2M2 + grid)		// DM2 to real metal
  FRAMECM2= SIZE M2DMY BY (dm2DM2 + grid)		// DM2 to dummy metal
  FRAMEM2Pre = (FRAMEAM2 OR FRAMECM2) OR M2ExcHole	// excluded holes
  #IFDEF CTM_OVER_M2
    FRAMEM2 = ((FRAMEM2Pre OR BLOCKM2) OR NFILL) OR CBMx
  #ELSE
    FRAMEM2 = (FRAMEM2Pre OR BLOCKM2) OR NFILL
  #ENDIF


  OPENM2 = PUSH ((minOPENM2 OR emptyOPENM2) AND CHIP)
  FILLM2 = OPENM2 NOT FRAMEM2
  FILLWM2pre = SIZE FILLM2 BY - (Wdm2M2 + grid)

// Large dummy pattern insertion
//================================
  FILLWM2A = (SIZE FILLWM2pre BY (WdmW_M2 - grid) UNDEROVER TRUNCATE WdmW_M2) AND FILLWM2pre
  FILLWM2 = SHRINK FILLWM2A LEFT BY Wdm_offset BOTTOM BY Wdm_offset 
  M2FW = RECTANGLES WdmW_M2 WdmL_M2 WdmS_M2 INSIDE OF LAYER FILLWM2
  M2FW_EXP = SIZE M2FW BY (WdmS_M2 / 2 + grid) OVERUNDER
  FILLMM2pre = FILLM2 NOT (SIZE M2FW_EXP BY (MdmS_M2 + grid))

// Middle dummy pattern insertion
//=================================
  FILLMM2A = (SIZE FILLMM2pre BY (MdmW_M2/2 - grid) UNDEROVER TRUNCATE MdmW_M2) AND FILLMM2pre 
  FILLMM2 = SHRINK FILLMM2A LEFT BY Mdm_offset BOTTOM BY Mdm_offset
  M2F1 = RECTANGLES MdmW_M2 MdmL_M2 MdmS_M2 INSIDE OF LAYER FILLMM2
  M2R1pre = FILLMM2pre NOT (SIZE M2F1 BY (dmS_M2 + grid))

// 1st small dummy pattern insertion
//====================================
  M2R1 = (SIZE M2R1pre BY (dmW_M2/2 - grid) UNDEROVER TRUNCATE dmW_M2) AND M2R1pre
  M2F2 = RECTANGLES dmW_M2 dmL_M2 dmS_M2 INSIDE OF LAYER M2R1
  M2R2pre = M2R1 NOT (SIZE M2F2 BY (dmS_M2 + grid))
    
// 2nd small dummy pattern insertion
//====================================
  M2R2 = (SIZE M2R2pre BY (dmW_M2/2 - grid) UNDEROVER TRUNCATE dmW_M2) AND M2R2pre
  M2F3 = RECTANGLES dmW_M2 dmL_M2 dmS_M2 INSIDE OF LAYER M2R2
  M2R3pre = M2R2 NOT (SIZE M2F3 BY (dmS_M2 + grid))
    
// 3rd small dummy pattern insertion
//====================================
  M2R3 = (SIZE M2R3pre BY (dmW_M2/2 - grid) UNDEROVER TRUNCATE dmW_M2) AND M2R3pre
  M2F4 = RECTANGLES dmW_M2 dmL_M2 dmS_M2 OFFSET dmO_M2 INSIDE OF LAYER M2R3 MAINTAIN SPACING

  M2F = (((M2F1 OR M2F2) OR M2F3) OR M2F4) OR M2FW
  FM2 = M2F NOT INTERACT (EXT M2F < dmS_M2 ABUT SINGULAR REGION)
	
  maxOPENM2 = DENSITY M2xd FM2 > maxD_M2 
		WINDOW WindowSize STEP WindowStep 
		INSIDE OF LAYER bulk
		BACKUP // PRINT M2Max.den
		
  DM2_FILL { @ Fill Dummy M2 pattern
    FM2 OUTSIDE maxOPENM2
  }	

#ENDIF
#IFDEF FILL_M3

  minOPENM3 = DENSITY M3xd < minD_M3
		WINDOW WindowSize STEP WindowStep 
		INSIDE OF LAYER bulk
		BACKUP // PRINT M3Min.den
  emptyOPENM3 = DENSITY M3xd < emptyD_M3
		WINDOW emptyWindowSize STEP emptyWindowStep 
		INSIDE OF LAYER bulk
		BACKUP // PRINT M3Empty.den

  M3InnerHole = HOLES M3x INNER
  M3BigHole = SIZE M3InnerHole BY - excludeHoleSize/2
  M3ExcHole = (M3InnerHole OUTSIDE M3BigHole) NOT M3x

  BLOCKM3 = SIZE DM3EXCL BY (dm2DMEXCL + grid)	// DM3 to DM3EXCL	
	
  FRAMEAM3 = SIZE M3x BY (dm2M3 + grid)		// DM3 to real metal
  FRAMECM3= SIZE M3DMY BY (dm2DM3 + grid)		// DM3 to dummy metal
  FRAMEM3Pre = (FRAMEAM3 OR FRAMECM3) OR M3ExcHole	// excluded holes
  #IFDEF CTM_OVER_M3
    FRAMEM3 = ((FRAMEM3Pre OR BLOCKM3) OR NFILL) OR CBMx
  #ELSE
    FRAMEM3 = (FRAMEM3Pre OR BLOCKM3) OR NFILL
  #ENDIF


  OPENM3 = PUSH ((minOPENM3 OR emptyOPENM3) AND CHIP)
  FILLM3 = OPENM3 NOT FRAMEM3
  FILLWM3pre = SIZE FILLM3 BY - (Wdm2M3 + grid)

// Large dummy pattern insertion
//================================
  FILLWM3 = (SIZE FILLWM3pre BY (WdmW_M3 - grid) UNDEROVER TRUNCATE WdmW_M3) AND FILLWM3pre 
  M3FW = RECTANGLES WdmW_M3 WdmL_M3 WdmS_M3 INSIDE OF LAYER FILLWM3
  M3FW_EXP = SIZE M3FW BY (WdmS_M3 / 2 + grid) OVERUNDER
  FILLMM3pre = FILLM3 NOT (SIZE M3FW_EXP BY (MdmS_M3 + grid))

// Middle dummy pattern insertion
//=================================
  FILLMM3 = (SIZE FILLMM3pre BY (MdmW_M3/2 - grid) UNDEROVER TRUNCATE MdmW_M3) AND FILLMM3pre 
  M3F1 = RECTANGLES MdmW_M3 MdmL_M3 MdmS_M3 INSIDE OF LAYER FILLMM3
  M3R1pre = FILLMM3pre NOT (SIZE M3F1 BY (dmS_M3 + grid))

// 1st small dummy pattern insertion
//====================================
  M3R1 = (SIZE M3R1pre BY (dmW_M3/2 - grid) UNDEROVER TRUNCATE dmW_M3) AND M3R1pre
  M3F2 = RECTANGLES dmW_M3 dmL_M3 dmS_M3 INSIDE OF LAYER M3R1
  M3R2pre = M3R1 NOT (SIZE M3F2 BY (dmS_M3 + grid))
    
// 2nd small dummy pattern insertion
//====================================
  M3R2 = (SIZE M3R2pre BY (dmW_M3/2 - grid) UNDEROVER TRUNCATE dmW_M3) AND M3R2pre
  M3F3 = RECTANGLES dmW_M3 dmL_M3 dmS_M3 INSIDE OF LAYER M3R2
  M3R3pre = M3R2 NOT (SIZE M3F3 BY (dmS_M3 + grid))
    
// 3rd small dummy pattern insertion
//====================================
  M3R3 = (SIZE M3R3pre BY (dmW_M3/2 - grid) UNDEROVER TRUNCATE dmW_M3) AND M3R3pre
  M3F4 = RECTANGLES dmW_M3 dmL_M3 dmS_M3 OFFSET dmO_M3 INSIDE OF LAYER M3R3 MAINTAIN SPACING

  M3F = (((M3F1 OR M3F2) OR M3F3) OR M3F4) OR M3FW
  FM3 = M3F NOT INTERACT (EXT M3F < dmS_M3 ABUT SINGULAR REGION)
	
  maxOPENM3 = DENSITY M3xd FM3 > maxD_M3 
		WINDOW WindowSize STEP WindowStep 
		INSIDE OF LAYER bulk
		BACKUP // PRINT M3Max.den
		
  DM3_FILL { @ Fill Dummy M3 pattern
    FM3 OUTSIDE maxOPENM3
  }	

#ENDIF
#IFDEF FILL_M4

  minOPENM4 = DENSITY M4xd < minD_M4
		WINDOW WindowSize STEP WindowStep 
		INSIDE OF LAYER bulk
		BACKUP // PRINT M4Min.den
  emptyOPENM4 = DENSITY M4xd < emptyD_M4
		WINDOW emptyWindowSize STEP emptyWindowStep 
		INSIDE OF LAYER bulk
		BACKUP // PRINT M4Empty.den

  M4InnerHole = HOLES M4x INNER
  M4BigHole = SIZE M4InnerHole BY - excludeHoleSize/2
  M4ExcHole = (M4InnerHole OUTSIDE M4BigHole) NOT M4x

  BLOCKM4 = SIZE DM4EXCL BY (dm2DMEXCL + grid)	// DM4 to DM4EXCL	
	
  FRAMEAM4 = SIZE M4x BY (dm2M4 + grid)		// DM4 to real metal
  FRAMECM4= SIZE M4DMY BY (dm2DM4 + grid)		// DM4 to dummy metal
  FRAMEM4Pre = (FRAMEAM4 OR FRAMECM4) OR M4ExcHole	// excluded holes
  #IFDEF CTM_OVER_M4
    FRAMEM4 = ((FRAMEM4Pre OR BLOCKM4) OR NFILL) OR CBMx
  #ELSE
    FRAMEM4 = (FRAMEM4Pre OR BLOCKM4) OR NFILL
  #ENDIF


  OPENM4 = PUSH ((minOPENM4 OR emptyOPENM4) AND CHIP)
  FILLM4 = OPENM4 NOT FRAMEM4
  FILLWM4pre = SIZE FILLM4 BY - (Wdm2M4 + grid)

// Large dummy pattern insertion
//================================
  FILLWM4A = (SIZE FILLWM4pre BY (WdmW_M4 - grid) UNDEROVER TRUNCATE WdmW_M4) AND FILLWM4pre
  FILLWM4 = SHRINK FILLWM4A LEFT BY Wdm_offset BOTTOM BY Wdm_offset 
  M4FW = RECTANGLES WdmW_M4 WdmL_M4 WdmS_M4 INSIDE OF LAYER FILLWM4
  M4FW_EXP = SIZE M4FW BY (WdmS_M4 / 2 + grid) OVERUNDER
  FILLMM4pre = FILLM4 NOT (SIZE M4FW_EXP BY (MdmS_M4 + grid))

// Middle dummy pattern insertion
//=================================
  FILLMM4A = (SIZE FILLMM4pre BY (MdmW_M4/2 - grid) UNDEROVER TRUNCATE MdmW_M4) AND FILLMM4pre 
  FILLMM4 = SHRINK FILLMM4A LEFT BY Mdm_offset BOTTOM BY Mdm_offset
  M4F1 = RECTANGLES MdmW_M4 MdmL_M4 MdmS_M4 INSIDE OF LAYER FILLMM4
  M4R1pre = FILLMM4pre NOT (SIZE M4F1 BY (dmS_M4 + grid))

// 1st small dummy pattern insertion
//====================================
  M4R1 = (SIZE M4R1pre BY (dmW_M4/2 - grid) UNDEROVER TRUNCATE dmW_M4) AND M4R1pre
  M4F2 = RECTANGLES dmW_M4 dmL_M4 dmS_M4 INSIDE OF LAYER M4R1
  M4R2pre = M4R1 NOT (SIZE M4F2 BY (dmS_M4 + grid))
    
// 2nd small dummy pattern insertion
//====================================
  M4R2 = (SIZE M4R2pre BY (dmW_M4/2 - grid) UNDEROVER TRUNCATE dmW_M4) AND M4R2pre
  M4F3 = RECTANGLES dmW_M4 dmL_M4 dmS_M4 INSIDE OF LAYER M4R2
  M4R3pre = M4R2 NOT (SIZE M4F3 BY (dmS_M4 + grid))
    
// 3rd small dummy pattern insertion
//====================================
  M4R3 = (SIZE M4R3pre BY (dmW_M4/2 - grid) UNDEROVER TRUNCATE dmW_M4) AND M4R3pre
  M4F4 = RECTANGLES dmW_M4 dmL_M4 dmS_M4 OFFSET dmO_M4 INSIDE OF LAYER M4R3 MAINTAIN SPACING

  M4F = (((M4F1 OR M4F2) OR M4F3) OR M4F4) OR M4FW
  FM4 = M4F NOT INTERACT (EXT M4F < dmS_M4 ABUT SINGULAR REGION)
	
  maxOPENM4 = DENSITY M4xd FM4 > maxD_M4 
		WINDOW WindowSize STEP WindowStep 
		INSIDE OF LAYER bulk
		BACKUP // PRINT M4Max.den
		
  DM4_FILL { @ Fill Dummy M4 pattern
    FM4 OUTSIDE maxOPENM4
  }	

#ENDIF
#IFDEF FILL_M5

  minOPENM5 = DENSITY M5xd < minD_M5
		WINDOW WindowSize STEP WindowStep 
		INSIDE OF LAYER bulk
		BACKUP // PRINT M5Min.den
  emptyOPENM5 = DENSITY M5xd < emptyD_M5
		WINDOW emptyWindowSize STEP emptyWindowStep 
		INSIDE OF LAYER bulk
		BACKUP // PRINT M5Empty.den

  M5InnerHole = HOLES M5x INNER
  M5BigHole = SIZE M5InnerHole BY - excludeHoleSize/2
  M5ExcHole = (M5InnerHole OUTSIDE M5BigHole) NOT M5x

  BLOCKM5 = SIZE DM5EXCL BY (dm2DMEXCL + grid)	// DM5 to DM5EXCL	
	
  FRAMEAM5 = SIZE M5x BY (dm2M5 + grid)		// DM5 to real metal
  FRAMECM5= SIZE M5DMY BY (dm2DM5 + grid)		// DM5 to dummy metal
  FRAMEM5Pre = (FRAMEAM5 OR FRAMECM5) OR M5ExcHole	// excluded holes
  #IFDEF CTM_OVER_M5
    FRAMEM5 = ((FRAMEM5Pre OR BLOCKM5) OR NFILL) OR CBMx
  #ELSE
    FRAMEM5 = (FRAMEM5Pre OR BLOCKM5) OR NFILL
  #ENDIF


  OPENM5 = PUSH ((minOPENM5 OR emptyOPENM5) AND CHIP)
  FILLM5 = OPENM5 NOT FRAMEM5
  FILLWM5pre = SIZE FILLM5 BY - (Wdm2M5 + grid)

// Large dummy pattern insertion
//================================
  FILLWM5 = (SIZE FILLWM5pre BY (WdmW_M5 - grid) UNDEROVER TRUNCATE WdmW_M5) AND FILLWM5pre 
  M5FW = RECTANGLES WdmW_M5 WdmL_M5 WdmS_M5 INSIDE OF LAYER FILLWM5
  M5FW_EXP = SIZE M5FW BY (WdmS_M5 / 2 + grid) OVERUNDER
  FILLMM5pre = FILLM5 NOT (SIZE M5FW_EXP BY (MdmS_M5 + grid))

// Middle dummy pattern insertion
//=================================
  FILLMM5 = (SIZE FILLMM5pre BY (MdmW_M5/2 - grid) UNDEROVER TRUNCATE MdmW_M5) AND FILLMM5pre 
  M5F1 = RECTANGLES MdmW_M5 MdmL_M5 MdmS_M5 INSIDE OF LAYER FILLMM5
  M5R1pre = FILLMM5pre NOT (SIZE M5F1 BY (dmS_M5 + grid))

// 1st small dummy pattern insertion
//====================================
  M5R1 = (SIZE M5R1pre BY (dmW_M5/2 - grid) UNDEROVER TRUNCATE dmW_M5) AND M5R1pre
  M5F2 = RECTANGLES dmW_M5 dmL_M5 dmS_M5 INSIDE OF LAYER M5R1
  M5R2pre = M5R1 NOT (SIZE M5F2 BY (dmS_M5 + grid))
    
// 2nd small dummy pattern insertion
//====================================
  M5R2 = (SIZE M5R2pre BY (dmW_M5/2 - grid) UNDEROVER TRUNCATE dmW_M5) AND M5R2pre
  M5F3 = RECTANGLES dmW_M5 dmL_M5 dmS_M5 INSIDE OF LAYER M5R2
  M5R3pre = M5R2 NOT (SIZE M5F3 BY (dmS_M5 + grid))
    
// 3rd small dummy pattern insertion
//====================================
  M5R3 = (SIZE M5R3pre BY (dmW_M5/2 - grid) UNDEROVER TRUNCATE dmW_M5) AND M5R3pre
  M5F4 = RECTANGLES dmW_M5 dmL_M5 dmS_M5 OFFSET dmO_M5 INSIDE OF LAYER M5R3 MAINTAIN SPACING

  M5F = (((M5F1 OR M5F2) OR M5F3) OR M5F4) OR M5FW
  FM5 = M5F NOT INTERACT (EXT M5F < dmS_M5 ABUT SINGULAR REGION)
	
  maxOPENM5 = DENSITY M5xd FM5 > maxD_M5 
		WINDOW WindowSize STEP WindowStep 
		INSIDE OF LAYER bulk
		BACKUP // PRINT M5Max.den
		
  DM5_FILL { @ Fill Dummy M5 pattern
    FM5 OUTSIDE maxOPENM5
  }	

#ENDIF
#IFDEF FILL_M6

  minOPENM6 = DENSITY M6xd < minD_M6
		WINDOW WindowSize STEP WindowStep 
		INSIDE OF LAYER bulk
		BACKUP // PRINT M6Min.den
  emptyOPENM6 = DENSITY M6xd < emptyD_M6
		WINDOW emptyWindowSize STEP emptyWindowStep 
		INSIDE OF LAYER bulk
		BACKUP // PRINT M6Empty.den

  M6InnerHole = HOLES M6x INNER
  M6BigHole = SIZE M6InnerHole BY - excludeHoleSize/2
  M6ExcHole = (M6InnerHole OUTSIDE M6BigHole) NOT M6x

  BLOCKM6 = SIZE DM6EXCL BY (dm2DMEXCL + grid)	// DM6 to DM6EXCL	
	
  FRAMEAM6 = SIZE M6x BY (dm2M6 + grid)		// DM6 to real metal
  FRAMECM6= SIZE M6DMY BY (dm2DM6 + grid)		// DM6 to dummy metal
  FRAMEM6Pre = (FRAMEAM6 OR FRAMECM6) OR M6ExcHole	// excluded holes
    FRAMEM6 = (FRAMEM6Pre OR BLOCKM6) OR NFILL


  OPENM6 = PUSH ((minOPENM6 OR emptyOPENM6) AND CHIP)
  FILLM6 = OPENM6 NOT FRAMEM6
  FILLWM6pre = SIZE FILLM6 BY - (Wdm2M6 + grid)

// Large dummy pattern insertion
//================================
  FILLWM6A = (SIZE FILLWM6pre BY (WdmW_M6 - grid) UNDEROVER TRUNCATE WdmW_M6) AND FILLWM6pre
  FILLWM6 = SHRINK FILLWM6A LEFT BY Wdm_offset BOTTOM BY Wdm_offset 
  M6FW = RECTANGLES WdmW_M6 WdmL_M6 WdmS_M6 INSIDE OF LAYER FILLWM6
  M6FW_EXP = SIZE M6FW BY (WdmS_M6 / 2 + grid) OVERUNDER
  FILLMM6pre = FILLM6 NOT (SIZE M6FW_EXP BY (MdmS_M6 + grid))

// Middle dummy pattern insertion
//=================================
  FILLMM6A = (SIZE FILLMM6pre BY (MdmW_M6/2 - grid) UNDEROVER TRUNCATE MdmW_M6) AND FILLMM6pre 
  FILLMM6 = SHRINK FILLMM6A LEFT BY Mdm_offset BOTTOM BY Mdm_offset
  M6F1 = RECTANGLES MdmW_M6 MdmL_M6 MdmS_M6 INSIDE OF LAYER FILLMM6
  M6R1pre = FILLMM6pre NOT (SIZE M6F1 BY (dmS_M6 + grid))

// 1st small dummy pattern insertion
//====================================
  M6R1 = (SIZE M6R1pre BY (dmW_M6/2 - grid) UNDEROVER TRUNCATE dmW_M6) AND M6R1pre
  M6F2 = RECTANGLES dmW_M6 dmL_M6 dmS_M6 INSIDE OF LAYER M6R1
  M6R2pre = M6R1 NOT (SIZE M6F2 BY (dmS_M6 + grid))
    
// 2nd small dummy pattern insertion
//====================================
  M6R2 = (SIZE M6R2pre BY (dmW_M6/2 - grid) UNDEROVER TRUNCATE dmW_M6) AND M6R2pre
  M6F3 = RECTANGLES dmW_M6 dmL_M6 dmS_M6 INSIDE OF LAYER M6R2
  M6R3pre = M6R2 NOT (SIZE M6F3 BY (dmS_M6 + grid))
    
// 3rd small dummy pattern insertion
//====================================
  M6R3 = (SIZE M6R3pre BY (dmW_M6/2 - grid) UNDEROVER TRUNCATE dmW_M6) AND M6R3pre
  M6F4 = RECTANGLES dmW_M6 dmL_M6 dmS_M6 OFFSET dmO_M6 INSIDE OF LAYER M6R3 MAINTAIN SPACING

  M6F = (((M6F1 OR M6F2) OR M6F3) OR M6F4) OR M6FW
  FM6 = M6F NOT INTERACT (EXT M6F < dmS_M6 ABUT SINGULAR REGION)
	
  maxOPENM6 = DENSITY M6xd FM6 > maxD_M6 
		WINDOW WindowSize STEP WindowStep 
		INSIDE OF LAYER bulk
		BACKUP // PRINT M6Max.den
		
  DM6_FILL { @ Fill Dummy M6 pattern
    FM6 OUTSIDE maxOPENM6
  }	

#ENDIF
#IFDEF FILL_MD

  minOPENMD = DENSITY MDxd < minD_MD
		WINDOW WindowSize STEP WindowStep 
		INSIDE OF LAYER bulk
		BACKUP // PRINT MDMin.den
  emptyOPENMD = DENSITY MDxd < emptyD_MD
		WINDOW emptyWindowSize STEP emptyWindowStep 
		INSIDE OF LAYER bulk
		BACKUP // PRINT MDEmpty.den

  MDInnerHole = HOLES MDx INNER
  MDBigHole = SIZE MDInnerHole BY - excludeHoleSize/2
  MDExcHole = (MDInnerHole OUTSIDE MDBigHole) NOT MDx

  BLOCKMD = SIZE DMDEXCL BY (dm2DMEXCL + grid)	// DMD to DMDEXCL	
	
  FRAMEAMD = SIZE MDx BY (dm2MD + grid)		// DMD to real metal
  FRAMECMD= SIZE MDDMY BY (dm2DMD + grid)		// DMD to dummy metal
  FRAMEMDPre = (FRAMEAMD OR FRAMECMD) OR MDExcHole	// excluded holes
    FRAMEMD = (FRAMEMDPre OR BLOCKMD) OR NFILL


  OPENMD = PUSH ((minOPENMD OR emptyOPENMD) AND CHIP)
  FILLMD = OPENMD NOT FRAMEMD
  FILLWMDpre = SIZE FILLMD BY - (Wdm2MD + grid)

// Large dummy pattern insertion
//================================
  FILLWMD = (SIZE FILLWMDpre BY (WdmW_MD - grid) UNDEROVER TRUNCATE WdmW_MD) AND FILLWMDpre 
  MDFW = RECTANGLES WdmW_MD WdmL_MD WdmS_MD INSIDE OF LAYER FILLWMD
  MDFW_EXP = SIZE MDFW BY (WdmS_MD / 2 + grid) OVERUNDER
  FILLMMDpre = FILLMD NOT (SIZE MDFW_EXP BY (MdmS_MD + grid))

// Middle dummy pattern insertion
//=================================
  FILLMMD = (SIZE FILLMMDpre BY (MdmW_MD/2 - grid) UNDEROVER TRUNCATE MdmW_MD) AND FILLMMDpre 
  MDF1 = RECTANGLES MdmW_MD MdmL_MD MdmS_MD INSIDE OF LAYER FILLMMD
  MDR1pre = FILLMMDpre NOT (SIZE MDF1 BY (dmS_MD + grid))

// 1st small dummy pattern insertion
//====================================
  MDR1 = (SIZE MDR1pre BY (dmW_MD/2 - grid) UNDEROVER TRUNCATE dmW_MD) AND MDR1pre
  MDF2 = RECTANGLES dmW_MD dmL_MD dmS_MD INSIDE OF LAYER MDR1
  MDR2pre = MDR1 NOT (SIZE MDF2 BY (dmS_MD + grid))
    
// 2nd small dummy pattern insertion
//====================================
  MDR2 = (SIZE MDR2pre BY (dmW_MD/2 - grid) UNDEROVER TRUNCATE dmW_MD) AND MDR2pre
  MDF3 = RECTANGLES dmW_MD dmL_MD dmS_MD INSIDE OF LAYER MDR2
  MDR3pre = MDR2 NOT (SIZE MDF3 BY (dmS_MD + grid))
    
// 3rd small dummy pattern insertion
//====================================
  MDR3 = (SIZE MDR3pre BY (dmW_MD/2 - grid) UNDEROVER TRUNCATE dmW_MD) AND MDR3pre
  MDF4 = RECTANGLES dmW_MD dmL_MD dmS_MD OFFSET dmO_MD INSIDE OF LAYER MDR3 MAINTAIN SPACING

  MDF = (((MDF1 OR MDF2) OR MDF3) OR MDF4) OR MDFW
  FMD = MDF NOT INTERACT (EXT MDF < dmS_MD ABUT SINGULAR REGION)
	
  maxOPENMD = DENSITY MDxd FMD > maxD_MD 
		WINDOW WindowSize STEP WindowStep 
		INSIDE OF LAYER bulk
		BACKUP // PRINT MDMax.den
		
  DMD_FILL { @ Fill Dummy MD pattern
    FMD OUTSIDE maxOPENMD
  }	

#ENDIF
#ENDCRYPT

#IFDEF MIXED_SCHEME  // MIXED_SCHEME
#IFDEF FILL_M1
  DRC CHECK MAP DM1_FILL 16 1
	AREF DM1_S dmW_M1 dmL_M1   // 2 
    AREF DM1_M MdmW_M1 MdmL_M1 // 2 
    AREF DM1_L WdmW_M1 WdmL_M1 // 2



#ENDIF	
#IFDEF FILL_M2
  DRC CHECK MAP DM2_FILL 18 1
	AREF DM2_S dmW_M2 dmL_M2   // 2 
    AREF DM2_M MdmW_M2 MdmL_M2 // 2 
    AREF DM2_L WdmW_M2 WdmL_M2 // 2



#ENDIF	
#IFDEF FILL_M3
  #IFDEF THICK_40K_M3
  DRC CHECK MAP DM3_FILL 28 1 
    AREF DM3_L WdmW_M3 WdmL_M3 // 2
  #ELSE
     #IFDEF THICK_30K_M3
  DRC CHECK MAP DM3_FILL 28 1 
    AREF DM3_L WdmW_M3 WdmL_M3 // 2
   #ELSE
        #IFDEF THICK_M3
  DRC CHECK MAP DM3_FILL 28 1 
    AREF DM3_L WdmW_M3 WdmL_M3 // 2 
  #ELSE
  DRC CHECK MAP DM3_FILL 28 1 
    AREF DM3_S dmW_M3 dmL_M3   // 2 
    AREF DM3_M MdmW_M3 MdmL_M3 // 2
    AREF DM3_L WdmW_M3 WdmL_M3 // 2
  #ENDIF
  #ENDIF
  #ENDIF
#ENDIF	
#IFDEF FILL_M4
  #IFDEF THICK_40K_M4
  DRC CHECK MAP DM4_FILL 31 1 
    AREF DM4_L WdmW_M4 WdmL_M4 // 2
  #ELSE
     #IFDEF THICK_30K_M4
  DRC CHECK MAP DM4_FILL 31 1 
    AREF DM4_L WdmW_M4 WdmL_M4 // 2
   #ELSE
        #IFDEF THICK_M4
  DRC CHECK MAP DM4_FILL 31 1 
    AREF DM4_L WdmW_M4 WdmL_M4 // 2 
  #ELSE
  DRC CHECK MAP DM4_FILL 31 1 
    AREF DM4_S dmW_M4 dmL_M4   // 2 
    AREF DM4_M MdmW_M4 MdmL_M4 // 2
    AREF DM4_L WdmW_M4 WdmL_M4 // 2
  #ENDIF
  #ENDIF
  #ENDIF
#ENDIF	
#IFDEF FILL_M5
  #IFDEF THICK_40K_M5
  DRC CHECK MAP DM5_FILL 33 1 
    AREF DM5_L WdmW_M5 WdmL_M5 // 2
  #ELSE
     #IFDEF THICK_30K_M5
  DRC CHECK MAP DM5_FILL 33 1 
    AREF DM5_L WdmW_M5 WdmL_M5 // 2
   #ELSE
        #IFDEF THICK_M5
  DRC CHECK MAP DM5_FILL 33 1 
    AREF DM5_L WdmW_M5 WdmL_M5 // 2 
  #ELSE
  DRC CHECK MAP DM5_FILL 33 1 
    AREF DM5_S dmW_M5 dmL_M5   // 2 
    AREF DM5_M MdmW_M5 MdmL_M5 // 2
    AREF DM5_L WdmW_M5 WdmL_M5 // 2
  #ENDIF
  #ENDIF
  #ENDIF
#ENDIF	
#IFDEF FILL_M6
  #IFDEF THICK_40K_M6
  DRC CHECK MAP DM6_FILL 38 1 
    AREF DM6_L WdmW_M6 WdmL_M6 // 2
  #ELSE
     #IFDEF THICK_30K_M6
  DRC CHECK MAP DM6_FILL 38 1 
    AREF DM6_L WdmW_M6 WdmL_M6 // 2
   #ELSE
        #IFDEF THICK_M6
  DRC CHECK MAP DM6_FILL 38 1 
    AREF DM6_L WdmW_M6 WdmL_M6 // 2 
  #ELSE
  DRC CHECK MAP DM6_FILL 38 1 
    AREF DM6_S dmW_M6 dmL_M6   // 2 
    AREF DM6_M MdmW_M6 MdmL_M6 // 2
    AREF DM6_L WdmW_M6 WdmL_M6 // 2
  #ENDIF
  #ENDIF
  #ENDIF
#ENDIF	
#IFDEF FILL_MD
  DRC CHECK MAP DMD_FILL 168 1
    AREF DMD_L WdmW_MD WdmL_MD // 2

#ENDIF	
#ELSE //IF NOT DEFINE MIXED_SCHEME
#IFDEF FILL_M1
  DRC CHECK MAP DM1_FILL 16 0
    AREF DM1_S dmW_M1 dmL_M1   // 2 
    AREF DM1_M MdmW_M1 MdmL_M1 // 2 
    AREF DM1_L WdmW_M1 WdmL_M1 // 2



#ENDIF	
#IFDEF FILL_M2
  DRC CHECK MAP DM2_FILL 18 0
    AREF DM2_S dmW_M2 dmL_M2   // 2 
    AREF DM2_M MdmW_M2 MdmL_M2 // 2 
    AREF DM2_L WdmW_M2 WdmL_M2 // 2



#ENDIF	
#IFDEF FILL_M3
  #IFDEF THICK_40K_M3
  DRC CHECK MAP DM3_FILL 28 0 
    AREF DM3_L WdmW_M3 WdmL_M3 // 2
  #ELSE
     #IFDEF THICK_30K_M3
    DRC CHECK MAP DM3_FILL 28 0 
    AREF DM3_L WdmW_M3 WdmL_M3 // 2
  #ELSE
        #IFDEF THICK_M3
    DRC CHECK MAP DM3_FILL 28 0 
    AREF DM3_L WdmW_M3 WdmL_M3 // 2
  #ELSE
  DRC CHECK MAP DM3_FILL 28 0 
    AREF DM3_S dmW_M3 dmL_M3   // 2
    AREF DM3_M MdmW_M3 MdmL_M3 // 2
    AREF DM3_L WdmW_M3 WdmL_M3 // 2
  #ENDIF
  #ENDIF
  #ENDIF
#ENDIF	
#IFDEF FILL_M4
  #IFDEF THICK_40K_M4
  DRC CHECK MAP DM4_FILL 31 0 
    AREF DM4_L WdmW_M4 WdmL_M4 // 2
  #ELSE
     #IFDEF THICK_30K_M4
    DRC CHECK MAP DM4_FILL 31 0 
    AREF DM4_L WdmW_M4 WdmL_M4 // 2
  #ELSE
        #IFDEF THICK_M4
    DRC CHECK MAP DM4_FILL 31 0 
    AREF DM4_L WdmW_M4 WdmL_M4 // 2
  #ELSE
  DRC CHECK MAP DM4_FILL 31 0 
    AREF DM4_S dmW_M4 dmL_M4   // 2
    AREF DM4_M MdmW_M4 MdmL_M4 // 2
    AREF DM4_L WdmW_M4 WdmL_M4 // 2
  #ENDIF
  #ENDIF
  #ENDIF
#ENDIF	
#IFDEF FILL_M5
  #IFDEF THICK_40K_M5
  DRC CHECK MAP DM5_FILL 33 0 
    AREF DM5_L WdmW_M5 WdmL_M5 // 2
  #ELSE
     #IFDEF THICK_30K_M5
    DRC CHECK MAP DM5_FILL 33 0 
    AREF DM5_L WdmW_M5 WdmL_M5 // 2
  #ELSE
        #IFDEF THICK_M5
    DRC CHECK MAP DM5_FILL 33 0 
    AREF DM5_L WdmW_M5 WdmL_M5 // 2
  #ELSE
  DRC CHECK MAP DM5_FILL 33 0 
    AREF DM5_S dmW_M5 dmL_M5   // 2
    AREF DM5_M MdmW_M5 MdmL_M5 // 2
    AREF DM5_L WdmW_M5 WdmL_M5 // 2
  #ENDIF
  #ENDIF
  #ENDIF
#ENDIF	
#IFDEF FILL_M6
  #IFDEF THICK_40K_M6
  DRC CHECK MAP DM6_FILL 38 0 
    AREF DM6_L WdmW_M6 WdmL_M6 // 2
  #ELSE
     #IFDEF THICK_30K_M6
    DRC CHECK MAP DM6_FILL 38 0 
    AREF DM6_L WdmW_M6 WdmL_M6 // 2
  #ELSE
        #IFDEF THICK_M6
    DRC CHECK MAP DM6_FILL 38 0 
    AREF DM6_L WdmW_M6 WdmL_M6 // 2
  #ELSE
  DRC CHECK MAP DM6_FILL 38 0 
    AREF DM6_S dmW_M6 dmL_M6   // 2
    AREF DM6_M MdmW_M6 MdmL_M6 // 2
    AREF DM6_L WdmW_M6 WdmL_M6 // 2
  #ENDIF
  #ENDIF
  #ENDIF
#ENDIF	
#IFDEF FILL_MD
  DRC CHECK MAP DMD_FILL 168 0
    AREF DMD_L WdmW_MD WdmL_MD // 2

#ENDIF	
#ENDIF // END OF MIXED_SCHEME

//---------------
// End Generation
//---------------
